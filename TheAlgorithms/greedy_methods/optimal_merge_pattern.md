# 최적 병합 패턴 (Optimal Merge Pattern)

이 문서는 `optimal_merge_pattern.py` 파일에 구현된 **최적 병합 패턴** 알고리즘에 대해 설명합니다.

## 개요

서로 다른 크기를 가진 정렬된 파일들을 하나의 정렬된 파일로 병합할 때, 필요한 총 비용(비교 횟수 또는 이동 횟수)을 최소화하는 문제입니다. 두 파일을 병합하는 비용은 두 파일 크기의 합이라고 가정합니다.

## 알고리즘 원리 (탐욕적 방법)

이 문제는 **탐욕적 알고리즘(Greedy Algorithm)**을 사용하여 해결할 수 있습니다. 전체 병합 비용을 최소화하려면, 매 단계마다 가장 크기가 작은 두 파일을 선택하여 병합해야 합니다. 이는 허프만 코딩(Huffman Coding) 트리 생성 방식과 유사합니다.

1. 파일 크기 리스트에서 가장 작은 두 값을 찾습니다.
2. 두 값을 더하여 병합 비용을 계산하고, 이를 총 비용(`optimal_merge_cost`)에 더합니다.
3. 리스트에서 선택된 두 값을 제거하고, 합쳐진 새로운 파일 크기(두 값의 합)를 리스트에 추가합니다.
4. 리스트에 파일이 하나만 남을 때까지 위 과정을 반복합니다.

## 주요 함수: `optimal_merge_pattern`

### `optimal_merge_pattern(files: list) -> float`

- **목적**: 주어진 파일 크기 리스트를 병합하는 데 드는 최소 비용을 계산합니다.
- **매개변수**:
  - `files`: 병합할 파일들의 크기가 담긴 리스트.
- **반환값**: 모든 파일을 병합하는 데 필요한 최적 비용.

### 동작 예시

입력: `[2, 3, 4]`

1. **1단계**:
   - 가장 작은 두 파일: 2, 3
   - 병합 비용: 2 + 3 = 5
   - 총 비용: 5
   - 리스트 상태: `[4, 5]` (4는 원래 있던 것, 5는 새로 생성된 것)

2. **2단계**:
   - 가장 작은 두 파일: 4, 5
   - 병합 비용: 4 + 5 = 9
   - 총 비용: 5 + 9 = 14
   - 리스트 상태: `[9]`

3. **종료**: 리스트에 9 하나만 남았으므로 종료. 최종 비용은 14입니다.

## 사용법

`if __name__ == "__main__":` 블록에서 `doctest`를 실행하여 코드를 검증합니다.

```python
optimal_merge_pattern([5, 10, 20, 30, 30])
# 결과: 205
```

## 참고 사항
- 현재 구현은 리스트에서 `min()`과 `pop()`을 반복적으로 사용하므로 시간 복잡도가 효율적이지 않을 수 있습니다.
- 대량의 데이터를 처리할 때는 **최소 힙(Min-Heap)** 자료구조(`heapq` 모듈)를 사용하여 최소값을 $O(\log N)$ 시간에 추출하도록 개선하는 것이 좋습니다.