# `transposition_cipher.py` 코드 설명

이 문서는 `transposition_cipher.py` 파이썬 스크립트에 포함된 함수들을 설명합니다. 이 스크립트는 문자의 위치를 재배열하는 **전치 암호(Transposition Cipher)**의 한 종류인 **열 전치 암호(Columnar Transposition Cipher)**를 구현합니다.

## 목차
1.  전치 암호란?
2.  함수 설명
    -   `encryptMessage(key, message)`
    -   `decryptMessage(key, message)`
    -   `main()`
3.  실행 방법
4.  코드 개선 제안

## 전치 암호란?

전치 암호는 평문의 문자 자체를 바꾸는 대신, 문자의 위치를 일정한 규칙에 따라 섞어서 암호문을 만드는 방식입니다. 이 스크립트에서 구현된 방식은 평문을 특정 개수의 열(column)을 가진 격자에 쓴 다음, 각 열을 순서대로 읽어 암호문을 만듭니다. 여기서 열의 개수가 **키(key)**가 됩니다.

**암호화 예시 (키 = 8):**
1.  평문 "Harshil Darji"를 8개의 열을 가진 격자에 씁니다.
    ```
    H a r s h i l   (공백)
    D a r j i
    ```
2.  각 열을 위에서 아래로 순서대로 읽습니다.
    -   1열: `HD`
    -   2열: `aa`
    -   3열: `rr`
    -   ...
    -   8열: ` ` (공백)
3.  읽은 문자들을 모두 이어 붙여 암호문을 만듭니다.

복호화는 이 과정의 역순으로, 암호문의 길이를 바탕으로 각 열에 몇 개의 문자가 들어갈지 계산한 후, 다시 격자를 채우고 가로로 읽어 평문을 복원합니다.

## 함수 설명

### `encryptMessage(key: int, message: str) -> str`

주어진 메시지를 전치 암호로 **암호화**합니다.

-   **알고리즘**:
    1.  `key` 개수만큼의 빈 문자열을 가진 리스트(`cipherText`)를 생성합니다.
    2.  `0`부터 `key-1`까지 각 열(`col`)을 순회합니다.
    3.  각 열에 대해, 평문에서 해당 열에 속하는 문자들을 `key`만큼 건너뛰며 찾아내어 `cipherText`의 해당 열에 추가합니다.
    4.  모든 열이 채워지면, `cipherText` 리스트의 모든 문자열을 이어 붙여 최종 암호문을 반환합니다.

### `decryptMessage(key: int, message: str) -> str`

전치 암호로 암호화된 메시지를 **복호화**합니다.

-   **알고리즘**:
    1.  암호문의 길이와 키를 바탕으로, 복호화될 격자의 열 개수(`numCols`), 행 개수(`numRows`), 그리고 마지막 열에서 비어있을 칸의 수(`numShadedBoxes`)를 계산합니다.
    2.  `numCols` 개수만큼의 빈 문자열을 가진 리스트(`plainText`)를 생성합니다.
    3.  암호문의 각 문자를 순서대로 `plainText`의 각 열에 채워 넣습니다. 이 때, 각 열의 길이를 계산된 `numRows`와 `numShadedBoxes`를 고려하여 결정합니다.
    4.  문자가 모두 채워진 `plainText` 리스트를 다시 가로 방향으로 읽어(각 열의 첫 번째 문자, 두 번째 문자, ... 순으로) 원래의 평문을 복원합니다.

### `main()`

사용자로부터 메시지, 키, 모드(암호화/복호화)를 입력받아 암호화를 시연하는 대화형 인터페이스를 제공합니다.

## 실행 방법

스크립트를 직접 실행하면 내장된 `doctest`를 통해 각 함수의 정확성을 테스트한 후, 사용자 입력을 받아 암호화 또는 복호화를 수행합니다.

```bash
python transposition_cipher.py
```

**실행 예시:**
```
Enter message: Hello World
Enter key [2-10]: 8
Encrypt/Decryption [e/d]: e
Output:
Hore llWd|
```

## 코드 개선 제안

1.  **`decryptMessage` 함수의 복잡성**: 복호화 함수의 로직, 특히 `numCols`, `numRows`, `numShadedBoxes`를 계산하고 이를 기반으로 `plainText` 리스트를 채우는 과정이 다소 복잡하고 이해하기 어렵습니다. 각 열의 길이를 미리 계산하여 리스트에 저장한 후, 암호문을 슬라이싱하여 각 열을 채우는 방식으로 로직을 단순화할 수 있습니다.

2.  **사용자 입력 유효성 검사**: `main` 함수에서 사용자가 키로 숫자가 아닌 값을 입력하거나, 유효하지 않은 범위의 키를 입력했을 때 발생하는 오류를 `try-except` 블록으로 처리하면 프로그램의 안정성을 높일 수 있습니다.

3.  **모듈화**: 이 스크립트의 암호화/복호화 함수는 `transposition_cipher_encrypt_decrypt_file.py`에서 사용됩니다. 두 파일의 관계를 고려할 때, 이 파일은 암호화 로직을 제공하는 순수한 라이브러리 모듈로 유지하고, 사용자 인터페이스(`main` 함수)는 별도의 실행 스크립트로 분리하는 것이 더 나은 설계일 수 있습니다.

4.  **효율적인 문자열 처리**: `encryptMessage` 함수에서 `cipherText[col] += ...`와 같이 루프 안에서 문자열을 더하는 것은 성능에 비효율적일 수 있습니다. 각 열에 해당하는 문자들을 리스트에 모은 후, 마지막에 `"".join()`으로 합치는 것이 더 좋습니다. (현재 구현은 열의 개수가 적어 큰 문제는 되지 않습니다.)