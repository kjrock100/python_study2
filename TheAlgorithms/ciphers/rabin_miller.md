# `rabin_miller.py` 코드 설명

이 문서는 `rabin_miller.py` 파이썬 스크립트에 포함된 함수들을 설명합니다. 이 스크립트는 매우 큰 수가 소수일 가능성이 높은지를 검사하는 확률적 알고리즘인 **라빈-밀러 소수 판별법(Rabin-Miller Primality Test)**을 구현합니다.

## 목차
1.  라빈-밀러 소수 판별법이란?
2.  함수 설명
    -   `rabinMiller(num)`
    -   `is_prime_low_num(num)`
    -   `generateLargePrime(keysize)`
3.  실행 방법
4.  코드 개선 제안

## 라빈-밀러 소수 판별법이란?

라빈-밀러 소수 판별법은 입력된 수 `n`이 소수인지 합성수인지를 매우 빠르고 효율적으로 판별하는 알고리즘입니다. 이 알고리즘은 확률에 기반하며, 여러 번의 테스트를 통과하면 해당 수가 소수일 확률이 매우 높아집니다.

**알고리즘 원리**:
페르마의 소정리(`a^(n-1) ≡ 1 (mod n)`)의 확장된 형태를 사용합니다. 소수 `n`에 대해, `n-1`을 `d * 2^s` (d는 홀수) 형태로 분해했을 때, `1 < a < n-1`인 임의의 정수 `a`에 대해 다음 두 조건 중 하나는 반드시 성립합니다.
1.  `a^d ≡ 1 (mod n)`
2.  `0 <= r < s`인 어떤 `r`에 대해 `a^(d * 2^r) ≡ -1 (mod n)`

만약 어떤 `a`에 대해 위 두 조건이 모두 성립하지 않으면, `n`은 **반드시 합성수**입니다. 반대로, 여러 `a` 값에 대해 테스트를 통과하면 `n`은 소수일 가능성이 매우 높습니다.

## 함수 설명

### `rabinMiller(num: int) -> bool`

주어진 정수 `num`에 대해 라빈-밀러 소수 판별 테스트를 수행합니다.

-   **알고리즘**:
    1.  `num-1`을 `d * 2^s` 형태로 분해합니다.
    2.  `5`번의 테스트를 반복합니다. (테스트 횟수가 많을수록 정확도가 높아집니다.)
    3.  각 테스트마다 `2`와 `num-2` 사이에서 임의의 정수 `a`를 선택합니다.
    4.  위에서 설명한 라빈-밀러 테스트의 두 조건을 검사합니다.
    5.  만약 테스트를 통과하지 못하면, `num`은 합성수이므로 즉시 `False`를 반환합니다.
    6.  `5`번의 테스트를 모두 통과하면, `num`은 소수일 가능성이 매우 높으므로 `True`를 반환합니다.

### `is_prime_low_num(num: int) -> bool`

주어진 정수 `num`이 소수인지 판별하는 주 함수입니다. 작은 소수들에 대한 최적화를 포함합니다.

-   **알고리즘**:
    1.  `num`이 2보다 작으면 `False`를 반환합니다.
    2.  미리 정의된 작은 소수 리스트(`lowPrimes`)에 `num`이 포함되어 있는지 확인합니다. 포함되어 있으면 `True`를 반환합니다.
    3.  `lowPrimes`의 각 소수로 `num`을 나누어 떨어지는지 확인합니다. 나누어 떨어지면 합성수이므로 `False`를 반환합니다. 이 과정은 작은 소인수를 가진 합성수를 빠르게 걸러냅니다.
    4.  위의 모든 검사를 통과하면, `rabinMiller(num)` 함수를 호출하여 최종적으로 소수 여부를 판별합니다.

### `generateLargePrime(keysize: int = 1024) -> int`

지정된 비트 크기(`keysize`)를 갖는 큰 소수를 생성합니다.

-   **알고리즘**:
    1.  `keysize` 비트 범위 내에서 무작위 홀수를 생성합니다.
    2.  `is_prime_low_num` 함수를 사용하여 이 수가 소수인지 판별합니다.
    3.  소수를 찾을 때까지 이 과정을 반복하고, 찾으면 해당 소수를 반환합니다.
-   **용도**: RSA나 엘가말(ElGamal)과 같은 공개키 암호 시스템에서 사용할 큰 소수를 생성하는 데 사용됩니다.

## 실행 방법

스크립트를 직접 실행하면 `generateLargePrime()` 함수를 호출하여 1024비트 크기의 큰 소수를 생성하고, `is_prime_low_num`으로 소수 여부를 다시 확인한 후 결과를 출력합니다.

```bash
python rabin_miller.py
```

**실행 결과 예시 (매번 다름):**
```
('Prime number:', 12345...[매우 긴 숫자]...67891)
('is_prime_low_num:', True)
```

## 코드 개선 제안

1.  **결정론적 라빈-밀러 테스트**: 이 스크립트는 확률적 테스트를 수행합니다. `deterministic_miller_rabin.py`에서처럼, 특정 범위의 수에 대해서는 정해진 `a` 값들로만 테스트해도 100% 정확하게 소수 여부를 판별할 수 있습니다. 이 결정론적 방식을 통합하면 특정 크기까지의 수에 대한 신뢰도를 높일 수 있습니다.

2.  **테스트 횟수 조절**: `rabinMiller` 함수에서 테스트 횟수가 `5`로 고정되어 있습니다. 이 횟수를 함수의 인자로 받아 조절할 수 있게 하면, 사용자가 원하는 정확도 수준을 선택할 수 있어 유연성이 향상됩니다. 일반적으로 키 크기가 클수록 더 많은 테스트가 권장됩니다.

3.  **`is_prime_low_num` 함수 이름**: 함수 이름이 "낮은 수에 대한 소수 판별"을 의미하지만, 실제로는 모든 크기의 수를 처리하는 주 판별 함수입니다. `is_prime`과 같이 더 일반적인 이름으로 변경하는 것이 함수의 역할을 더 잘 나타냅니다.

4.  **`lowPrimes` 리스트 확장**: `lowPrimes` 리스트는 1000 미만의 소수만 포함하고 있습니다. 더 많은 소수를 포함하도록 리스트를 확장하거나, 특정 범위까지의 소수를 동적으로 생성하는 "에라토스테네스의 체"와 같은 알고리즘을 사용하면, 더 큰 합성수를 초기에 더 효율적으로 걸러낼 수 있습니다.