# `diffie.py` 코드 설명

이 문서는 `diffie.py` 파이썬 스크립트를 설명합니다. 이 스크립트는 **디피-헬만 키 교환(Diffie-Hellman Key Exchange)** 프로토콜의 기본적인 수학적 개념을 시연하는 간단한 구현입니다.

> **참고**: 이 스크립트는 교육 목적으로 제작되었으며, 실제 보안 환경에서 사용하기에는 안전하지 않습니다. 실제 애플리케이션에서는 `diffie_hellman.py`와 같이 검증된 그룹과 암호학적으로 안전한 난수 생성을 사용하는 것이 필수적입니다.

## 목차
1.  디피-헬만 키 교환이란?
2.  함수 설명
    -   `find_primitive(n)`
3.  실행 로직 (`if __name__ == "__main__"`)
4.  실행 방법
5.  코드의 한계 및 개선 제안

## 디피-헬만 키 교환이란?

디피-헬만 키 교환은 두 참여자가 공개된 통신 채널을 통해 공통의 비밀 키를 생성할 수 있게 하는 암호학적 프로토콜입니다.

**동작 원리**:
1.  **공개 매개변수 동의**: 두 참여자는 공개적으로 알려진 소수 `q`와 그 소수의 **원시근(primitive root)** `a`에 동의합니다.
2.  **개인키 생성**: 각 참여자는 자신만 아는 비밀 정수(개인키)를 선택합니다.
3.  **공개키 생성 및 교환**: 각 참여자는 `(a ^ 개인키) mod q`를 계산하여 공개키를 만들고 서로 교환합니다.
4.  **공유 비밀키 생성**: 각 참여자는 상대방에게 받은 공개키에 자신의 개인키를 사용하여 `(상대방 공개키 ^ 자신의 개인키) mod q`를 계산합니다. 수학적 원리에 따라 두 참여자는 동일한 공유 비밀키를 얻게 됩니다.

## 함수 설명

### `find_primitive(n: int) -> int | None`

주어진 소수 `n`에 대한 **원시근(primitive root)** 중 하나를 찾습니다.

-   **원시근이란?**: 어떤 소수 `n`에 대해, 정수 `r`을 1부터 `n-2`까지 거듭제곱하고 각각 `n`으로 나눈 나머지가 모두 다를 때, `r`을 `n`의 원시근이라고 합니다. 즉, `r`의 거듭제곱이 모듈러 `n` 상에서 1부터 `n-1`까지의 모든 수를 생성할 수 있습니다. 디피-헬만 프로토콜에서는 이 원시근을 생성자(generator)로 사용합니다.
-   **알고리즘**:
    1.  `1`부터 `n-1`까지의 모든 수 `r`을 후보로 하여 반복합니다.
    2.  각 후보 `r`에 대해, `r^0, r^1, ..., r^(n-2)`를 모듈러 `n` 상에서 계산하여 그 결과들이 중복되는지 확인합니다.
    3.  중복이 없으면, 해당 `r`을 원시근으로 간주하고 반환합니다.
    4.  모든 후보를 확인해도 원시근을 찾지 못하면 `None`을 반환합니다.
-   **주의**: 이 함수는 원시근을 찾기 위해 모든 경우를 시도하는 **전사 방식(brute-force)**을 사용하므로, 큰 소수에 대해서는 매우 비효율적입니다.

## 실행 로직 (`if __name__ == "__main__"`)

스크립트가 직접 실행될 때, 디피-헬만 키 교환 과정을 단계별로 시연합니다.

1.  사용자로부터 소수 `q`를 입력받습니다.
2.  `find_primitive(q)`를 호출하여 생성자 `a`를 찾습니다.
3.  사용자 A와 B의 개인키를 각각 입력받습니다.
4.  A와 B의 공개키를 계산합니다. (`a_public`, `b_public`)
5.  A와 B가 각각 공유 비밀키를 계산합니다. (`a_secret`, `b_secret`)
6.  최종적으로 계산된 두 공유 비밀키가 동일함을 보여주기 위해 두 값을 모두 출력합니다.

## 실행 방법

스크립트를 직접 실행하면 사용자 입력을 받아 키 교환을 시뮬레이션합니다.

```bash
python diffie.py
```

**실행 예시:**
```
Enter a prime number q: 23
Enter private key of A: 6
Enter private key of B: 15
The key value generated by A is:  2
The key value generated by B is:  2
```

## 코드의 한계 및 개선 제안

1.  **보안 취약성**:
    -   사용자가 직접 소수와 개인키를 입력하는 방식은 안전하지 않습니다. 실제 환경에서는 매우 큰 소수(2048비트 이상)와 암호학적으로 안전한 난수 생성기를 사용해야 합니다.
    -   `find_primitive` 함수는 매우 비효율적이며, 작은 소수에만 적용 가능합니다. 실제로는 RFC 3526 등 표준에 정의된 안전한 소수와 생성자 그룹을 사용해야 합니다.

2.  **효율성 문제**: `find_primitive` 함수는 리스트에 값을 추가하고 `in` 연산자로 중복을 확인합니다. 리스트에서의 `in` 연산은 O(n)의 시간 복잡도를 가지므로, `set`을 사용하여 O(1)으로 개선할 수 있습니다.

    ```python
    # 개선 제안 예시
    def find_primitive(n: int) -> int | None:
        for r in range(1, n):
            seen = set()
            is_primitive = True
            for x in range(n - 1):
                val = pow(r, x, n)
                if val in seen:
                    is_primitive = False
                    break
                seen.add(val)
            if is_primitive:
                return r
        return None
    ```

3.  **입력 유효성 검사 부재**: 사용자가 소수가 아닌 수를 입력하거나, 유효하지 않은 개인키를 입력했을 때 발생하는 오류를 처리하는 로직이 없습니다. `try-except` 블록과 소수 판별 함수를 추가하여 안정성을 높일 수 있습니다.
