# `rsa_factorization.py` 코드 설명

이 문서는 `rsa_factorization.py` 파이썬 스크립트에 포함된 `rsafactor` 함수를 설명합니다. 이 스크립트는 RSA 암호 시스템의 공개키(`e`, `N`)와 개인키(`d`)가 주어졌을 때, 모듈러스 `N`을 구성하는 두 개의 소인수 `p`와 `q`를 찾아내는 알고리즘을 구현합니다.

## 목차
1.  RSA 소인수분해란?
2.  함수 설명
    -   `rsafactor(d, e, N)`
3.  실행 방법
4.  코드 개선 제안

## RSA 소인수분해란?

RSA 암호의 보안은 매우 큰 수 `N`을 소인수분해하는 것이 계산적으로 어렵다는 사실에 기반합니다. 하지만 만약 어떤 방법으로든 개인키 `d`가 노출된다면, 공개키 `e`와 모듈러스 `N`을 이용하여 `N`을 소인수분해하고 RSA 시스템을 깰 수 있습니다.

이 스크립트는 바로 그 과정을 구현한 것으로, `d`와 `e`를 알 때 `N = p * q`를 만족하는 `p`와 `q`를 효율적으로 찾는 방법을 보여줍니다.

## 함수 설명

### `rsafactor(d: int, e: int, N: int) -> list[int]`

RSA 개인키(`d`), 공개키(`e`), 그리고 모듈러스(`N`)를 사용하여 `N`의 소인수 `p`와 `q`를 찾습니다.

-   **알고리즘**:
    1.  **`k` 계산**: `k = d * e - 1`을 계산합니다. RSA 키 생성 원리에 따라, `k`는 `(p-1)(q-1)`의 배수가 됩니다.
    2.  **`k` 분해**: `k`를 `t * 2^s` 형태로 분해합니다. (단, `t`는 홀수)
    3.  **무작위 `g` 선택**: `2`와 `N-1` 사이에서 무작위 정수 `g`를 선택합니다.
    4.  **소인수 탐색**:
        -   `x = g^t mod N`을 계산합니다.
        -   만약 `x`가 1이나 `N-1`이 아니라면, `x`를 반복적으로 제곱(`x = x^2 mod N`)하면서 `gcd(x-1, N)`을 계산합니다.
        -   `gcd(x-1, N)`의 결과가 1보다 크면, 이 값이 바로 `N`의 소인수 중 하나(`p` 또는 `q`)입니다.
        -   만약 `x`가 `N-1`이 되면, 이 `g`로는 소인수를 찾지 못한 것이므로, 새로운 `g`를 선택하여 과정을 반복합니다.
    5.  **결과 반환**: 찾은 소인수 `p`와 `q = N // p`를 리스트에 담아 정렬하여 반환합니다.

이 알고리즘은 밀러-라빈 소수 판별법의 아이디어를 응용한 것으로, 높은 확률로 소인수를 빠르게 찾을 수 있습니다.

## 실행 방법

스크립트를 직접 실행하면 내장된 `doctest`를 통해 함수의 예제 코드가 실행되고, 함수의 정확성이 자동으로 테스트됩니다.

```bash
python rsa_factorization.py
```

별도의 출력이 없다면 모든 테스트가 성공적으로 통과한 것입니다.

## 코드 개선 제안

1.  **알고리즘 로직 개선**: 현재 `while True` 루프와 `if t % 2 == 0` 조건문으로 `k`를 분해하고 `x`를 계산하는 로직이 다소 복잡하고 비효율적입니다. `k`를 `t * 2^s` 형태로 먼저 분해한 후, `x = g^t mod N`을 계산하고 `s`번 제곱하는 방식으로 로직을 명확하게 분리하면 가독성과 효율성이 향상됩니다.

    ```python
    # 개선 제안 예시
    def rsafactor_improved(d: int, e: int, N: int) -> list[int]:
        k = d * e - 1
        t = k
        while t % 2 == 0:
            t //= 2
        
        while True:
            g = random.randint(2, N - 1)
            x = pow(g, t, N)
            
            if x == 1 or x == N - 1:
                continue
            
            y = 0
            while y != N - 1:
                y = pow(x, 2, N)
                if y == 1:
                    p = math.gcd(x - 1, N)
                    return sorted([p, N // p])
                x = y
    ```

2.  **변수명 명확화**: `k`, `g`, `t`, `x`, `y`와 같은 변수명은 알고리즘에 대한 사전 지식이 없으면 이해하기 어렵습니다. `k_multiple`, `base`, `odd_part`, `temp_x`, `factor_candidate` 등 더 의미 있는 이름으로 변경하면 코드의 의도를 파악하는 데 도움이 됩니다.

3.  **`math.gcd` 사용**: `math.gcd`는 파이썬 3.5부터 표준 라이브러리에 포함되었습니다. 이 함수를 사용하는 것이 더 표준적이고 간결합니다. (현재 코드에서는 이미 잘 사용하고 있습니다.)