# `onepad_cipher.py` 코드 설명

이 문서는 `onepad_cipher.py` 파이썬 스크립트에 포함된 `Onepad` 클래스를 설명합니다. 이 스크립트는 **일회용 패드(One-Time Pad)**의 개념을 차용한 간단한 암호화 및 복호화 알고리즘을 구현합니다.

> **경고**: 이 스크립트는 교육 목적으로 제작되었으며, 실제 보안 환경에서 사용하기에는 **매우 안전하지 않습니다**. 실제 일회용 패드 암호의 엄격한 요구사항을 충족하지 않습니다.

## 목차
1.  암호 알고리즘 설명
2.  `Onepad` 클래스
    -   `encrypt(text)`
    -   `decrypt(cipher, key)`
3.  실행 방법
4.  코드의 한계 및 개선 제안

## 암호 알고리즘 설명

이 스크립트는 평문의 각 문자에 대해 고유한 난수 키를 생성하여 암호화를 수행합니다. 이는 "모든 메시지 조각에 대해 새로운 키를 사용한다"는 일회용 패드의 기본 아이디어와 유사합니다.

**암호화 공식**:
`암호문 숫자(C) = (평문 문자의 ASCII 값(P) + 난수 키(K)) * K`

**복호화 공식**:
암호화 공식을 역으로 계산하여 평문을 복원합니다.
`P = (C / K) - K`

각 문자에 대해 서로 다른 난수 `K`가 생성되므로, 복호화를 위해서는 암호문과 함께 생성된 키의 전체 시퀀스가 필요합니다.

## `Onepad` 클래스

암호화 및 복호화 기능을 정적 메서드(static method)로 제공하는 클래스입니다.

### `encrypt(text: str) -> tuple[list[int], list[int]]`

주어진 텍스트를 암호화합니다.

-   **알고리즘**:
    1.  평문(`text`)의 각 문자를 ASCII 코드 값으로 변환합니다.
    2.  각 ASCII 값 `i`에 대해, 1과 300 사이의 난수 `k`를 생성합니다.
    3.  `c = (i + k) * k` 공식을 사용하여 암호화된 숫자 `c`를 계산합니다.
    4.  계산된 `c`는 암호문 리스트에, 생성된 `k`는 키 리스트에 각각 추가합니다.
-   **반환값**: `(암호문 숫자 리스트, 키 숫자 리스트)` 형태의 튜플.

### `decrypt(cipher: list[int], key: list[int]) -> str`

암호문과 키 리스트를 사용하여 원래의 텍스트로 복호화합니다.

-   **알고리즘**:
    1.  암호문 리스트와 키 리스트를 순회합니다.
    2.  각 암호문 숫자 `c`와 키 `k`에 대해, `p = (c / k) - k` 공식을 사용하여 원래 문자의 ASCII 값 `p`를 계산합니다.
    3.  계산된 ASCII 값을 다시 문자로 변환합니다.
    4.  복원된 모든 문자를 하나의 문자열로 합쳐 반환합니다.

## 실행 방법

스크립트를 직접 실행하면 "Hello"라는 문자열을 암호화하고, 생성된 암호문과 키를 사용하여 다시 복호화하는 과정을 시연하고 결과를 출력합니다.

```bash
python onepad_cipher.py
```

**실행 결과 예시 (난수이므로 매번 다름):**
```
([29920, 20125, 29832, 29832, 42120], [160, 125, 156, 156, 180])
Hello
```

## 코드의 한계 및 개선 제안

1.  **보안 취약성**:
    -   **진정한 난수 아님**: `random.randint`는 암호학적으로 안전하지 않은 **유사 난수 생성기(PRNG)**입니다. 진정한 일회용 패드는 예측 불가능한 물리적 현상에서 얻은 완전한 난수를 사용해야 합니다.
    -   **키 재사용**: 이 스크립트를 여러 번 실행하면 같은 키 값이 다시 생성될 수 있습니다. 일회용 패드의 핵심 원칙은 키를 단 한 번만 사용하는 것입니다.
    -   **통계적 취약점**: 암호화 공식 `c = (i + k) * k`는 평문(i)과 키(k) 사이에 복잡한 수학적 관계를 만듭니다. 이는 암호문 자체에 평문에 대한 정보를 일부 노출시킬 수 있으며, 통계적 분석에 취약할 수 있습니다. (예: `c`는 `k`의 배수임)

2.  **개선 방향**:
    -   **암호학적 난수 사용**: `random` 모듈 대신, 암호학적 용도로 설계된 `secrets` 모듈을 사용하는 것이 좋습니다. (예: `secrets.randbelow(300) + 1`)
    -   **표준 OTP 구현**: 더 안전한 일회용 패드를 구현하려면, 덧셈과 곱셈 대신 **XOR 연산**을 사용하는 것이 표준적입니다. XOR 연산은 통계적 특성을 숨기는 데 더 효과적입니다.

    ```python
    # XOR 기반의 간단한 OTP 예시
    import secrets

    def encrypt_xor(text: str) -> tuple[bytes, bytes]:
        text_bytes = text.encode('utf-8')
        key = secrets.token_bytes(len(text_bytes))
        cipher_bytes = bytes([p ^ k for p, k in zip(text_bytes, key)])
        return cipher_bytes, key

    def decrypt_xor(cipher: bytes, key: bytes) -> str:
        plain_bytes = bytes([c ^ k for c, k in zip(cipher, key)])
        return plain_bytes.decode('utf-8')
    ```

3.  **정적 메서드**: `Onepad` 클래스는 상태를 가지지 않고 정적 메서드만 포함하고 있습니다. 이 경우, 클래스로 묶기보다는 모듈 수준에서 두 개의 독립적인 함수(`encrypt`, `decrypt`)로 정의하는 것이 더 간단하고 자연스러울 수 있습니다.