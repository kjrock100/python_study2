# `deterministic_miller_rabin.py` 코드 설명

이 문서는 `deterministic_miller_rabin.py` 파이썬 스크립트에 포함된 함수들을 설명합니다. 이 스크립트는 매우 큰 수가 소수인지 판별하는 데 사용되는 **결정론적 밀러-라빈 소수 판별법(Deterministic Miller-Rabin Primality Test)**을 구현합니다.

## 목차
1.  밀러-라빈 소수 판별법이란?
2.  함수 설명
    -   `miller_rabin(n, allow_probable)`
    -   `test_miller_rabin()`
3.  실행 방법
4.  코드 개선 제안

## 밀러-라빈 소수 판별법이란?

밀러-라빈 소수 판별법은 입력된 수가 소수일 가능성이 높은지를 검사하는 확률적 알고리즘입니다. 페르마의 소정리(Fermat's Little Theorem)를 기반으로 하며, 여러 번의 테스트를 통과하면 해당 수가 소수일 확률이 매우 높아집니다.

이 스크립트는 일반적인 확률적 방식에서 더 나아가, 특정 범위의 수에 대해서는 **결정론적으로(deterministically)**, 즉 100% 정확하게 소수 여부를 판별합니다. 이는 특정 수까지는 정해진 소수들(`primes` 리스트)로만 테스트해도 충분하다는 수학적 분석 결과를 활용하기 때문입니다. 이 스크립트는 약 3.3 x 10²⁴ 까지의 수에 대해 결정론적 판별을 지원합니다.

## 함수 설명

### `miller_rabin(n: int, allow_probable: bool = False) -> bool`

주어진 정수 `n`이 소수인지 판별합니다.

-   **인자**:
    -   `n`: 판별할 정수.
    -   `allow_probable` (선택): `True`로 설정하면, 결정론적 판별 범위를 넘어서는 수에 대해서도 확률적 테스트를 수행합니다.

-   **알고리즘**:
    1.  **기본 검사**: `n`이 2이거나, 2로 나누어 떨어지거나, 2보다 작으면 즉시 결과를 반환합니다. 또한, 5보다 큰 수의 마지막 자리가 1, 3, 7, 9가 아니면 합성수이므로 `False`를 반환합니다.
    2.  **결정론적 범위 확인**: `n`이 결정론적 판별이 보장된 최대 범위(`3.3 x 10²⁴...`)를 초과하고 `allow_probable`이 `False`이면 `ValueError`를 발생시킵니다.
    3.  **테스트할 소수 목록 선택**: `n`의 크기에 따라, 결정론적 판별에 필요한 최소한의 소수 목록(`plist`)을 `bounds`와 `primes` 리스트를 참조하여 선택합니다.
    4.  **n-1 분해**: `n-1`을 `d * 2^s` 형태로 분해합니다. (단, `d`는 홀수)
    5.  **밀러-라빈 테스트 수행**:
        -   선택된 소수 목록(`plist`)의 각 소수 `a`에 대해 다음을 반복합니다.
        -   `a^d ≡ 1 (mod n)` 이거나, `0 <= r < s`인 어떤 `r`에 대해 `a^(d * 2^r) ≡ -1 (mod n)` 이면, `n`은 이 테스트를 통과한 것으로 간주하고 다음 소수로 넘어갑니다.
        -   만약 어떤 소수 `a`에 대해 위 두 조건을 모두 만족하지 못하면, `n`은 **반드시 합성수**이므로 즉시 `False`를 반환합니다.
    6.  **결과 반환**: `plist`의 모든 소수에 대한 테스트를 통과하면, `n`은 소수(또는 확률적 소수)이므로 `True`를 반환합니다.

### `test_miller_rabin()`

`miller_rabin` 함수의 정확성을 검증하기 위한 테스트 함수입니다.

-   **동작**: 결정론적 판별 범위의 각 구간에 대해, 알려진 합성수와 소수를 각각 `miller_rabin` 함수로 테스트하여 `assert` 문을 통해 결과가 올바른지 확인합니다.

## 실행 방법

스크립트를 직접 실행하면 `test_miller_rabin()` 함수가 호출되어 내장된 테스트 케이스들이 실행됩니다.

```bash
python deterministic_miller_rabin.py
```

별도의 출력이 없다면 모든 테스트가 성공적으로 통과한 것입니다.

## 코드 개선 제안

1.  **`bounds` 리스트의 `1` 값**: `bounds` 리스트에 포함된 `1` 값들은 특정 범위의 테스트에 필요한 소수 목록이 이전 범위와 동일함을 나타내는 것으로 보입니다. 이는 코드의 가독성을 떨어뜨릴 수 있습니다. 이 부분을 주석으로 명확히 설명하거나, `dict`를 사용하여 각 경계값에 해당하는 소수 목록의 길이를 명시적으로 매핑하는 것이 더 명확할 수 있습니다.

    ```python
    # 개선 제안 예시
    BOUNDS_TO_PRIMES_COUNT = {
        2_047: 1,
        1_373_653: 2,
        25_326_001: 3,
        # ...
    }
    ```

2.  **`plist` 선택 로직 개선**: 현재 `for` 루프와 `break`를 사용하여 `plist`를 결정하는 로직은 `bisect` 모듈을 사용하면 더 효율적이고 간결하게 작성할 수 있습니다. `bisect.bisect_left`는 정렬된 리스트에서 특정 값의 위치를 빠르게 찾아줍니다.

    ```python
    # 개선 제안 예시
    import bisect
    
    # ...
    idx = bisect.bisect_left(bounds, n)
    plist = primes[:idx + 1]
    ```

3.  **변수명 명확화**: `pr`이라는 변수명은 'prime' 또는 'probable'을 의미하는 것으로 보이지만, `is_probable_prime`이나 `test_passed`와 같이 더 명확한 이름으로 변경하면 코드의 의도를 파악하기 쉬워집니다.

4.  **`doctest` 활용**: `test_miller_rabin` 함수는 훌륭한 테스트 케이스를 포함하고 있습니다. 이 테스트들을 `doctest` 형식으로 `miller_rabin` 함수의 docstring에 포함시키면, 코드를 문서화하는 동시에 테스트를 자동화할 수 있어 일석이조의 효과를 얻을 수 있습니다.
