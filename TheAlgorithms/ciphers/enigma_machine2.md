# `enigma_machine2.py` 코드 설명

이 문서는 `enigma_machine2.py` 파이썬 스크립트를 설명합니다. 이 스크립트는 제2차 세계대전 당시 독일군이 사용했던 유명한 암호 기계인 **에니그마(Enigma)**의 동작을 시뮬레이션합니다.

## 목차
1.  에니그마 암호기란?
2.  주요 구성 요소
3.  함수 설명
    -   `_plugboard(pbstring)`
    -   `_validator(rotpos, rotsel, pb)`
    -   `enigma(text, rotor_position, rotor_selection, plugb)`
4.  실행 방법
5.  코드 개선 제안

## 에니그마 암호기란?

에니그마는 회전하는 로터(rotor)들을 사용하여 문자를 복잡하게 치환하는 전기-기계식 암호 장치입니다. 키를 누를 때마다 로터가 회전하여 매번 다른 치환 규칙이 적용되므로, 단순 치환 암호보다 훨씬 해독하기 어렵습니다.

**암호화 과정**:
1.  키보드에서 문자를 입력하면 전류가 흐릅니다.
2.  전류는 **플러그보드(Plugboard)**를 통과하며 일부 문자가 서로 교환될 수 있습니다.
3.  전류는 3개의 **로터(Rotor)**를 순서대로 통과하며 복잡한 치환을 거칩니다.
4.  전류는 **반사판(Reflector)**에 도달하여 다시 반사됩니다.
5.  반사된 전류는 로터들을 역순으로 다시 통과합니다.
6.  전류는 플러그보드를 한 번 더 통과합니다.
7.  최종적으로 램프보드의 특정 램프에 불이 들어와 암호화된 문자를 표시합니다.

하나의 문자가 암호화될 때마다 첫 번째 로터가 한 칸 회전하며, 특정 지점에 도달하면 다음 로터도 회전하게 됩니다. 이 스크립트는 이러한 기계적 동작을 소프트웨어로 구현합니다.

## 주요 구성 요소

-   **`abc`**: 기준이 되는 알파벳 문자열 (`"ABCDEFGHIJKLMNOPQRSTUVWXYZ"`)
-   **`rotor1` ~ `rotor9`**: 9개의 서로 다른 배선 구조를 가진 로터들입니다. 각 로터는 알파벳을 특정 순서로 섞어놓은 문자열로 표현됩니다.
-   **`reflector`**: 반사판으로, 특정 문자 쌍을 서로 교환하는 딕셔너리입니다. 에니그마의 중요한 특징 중 하나는 암호화와 복호화 과정이 동일하다는 것인데, 이는 반사판의 대칭적인 구조 덕분입니다.

## 함수 설명

### `_plugboard(pbstring: str) -> dict[str, str]`

플러그보드 설정을 나타내는 문자열을 입력받아, 문자 교환을 위한 딕셔너리를 생성합니다.

-   **알고리즘**:
    -   입력 문자열(`pbstring`)을 두 글자씩 짝지어, 서로를 교환하는 딕셔너리 항목을 만듭니다. (예: "PO" -> `{'P': 'O', 'O': 'P'}`)
    -   입력 문자열의 유효성(짝수 길이, 중복 문자 없음 등)을 검사합니다.

### `_validator(rotpos, rotsel, pb)`

에니그마 함수에 전달된 설정값(로터 위치, 로터 선택, 플러그보드)이 유효한지 검증합니다.

-   **검사 항목**:
    -   선택된 3개의 로터가 모두 다른지 확인합니다.
    -   로터의 초기 위치 값이 1과 26 사이인지 확인합니다.
    -   `_plugboard` 함수를 호출하여 플러그보드 설정의 유효성을 검사하고 딕셔너리를 생성합니다.

### `enigma(text, rotor_position, rotor_selection, plugb)`

주어진 설정으로 텍스트를 암호화하거나 복호화합니다.

-   **알고리즘**:
    1.  입력된 텍스트를 대문자로 변환하고, `_validator`를 통해 설정값을 검증합니다.
    2.  텍스트의 각 문자에 대해 다음 과정을 반복합니다.
        -   **플러그보드 (1차)**: 문자가 플러그보드에 연결되어 있으면 교환합니다.
        -   **로터 통과 (정방향)**: 1, 2, 3번 로터를 차례로 통과하며 문자를 치환합니다. 각 로터를 통과할 때 현재 로터의 위치만큼 인덱스를 이동시킨 후 치환합니다.
        -   **반사판**: 반사판 딕셔너리를 통해 문자를 교환합니다.
        -   **로터 통과 (역방향)**: 3, 2, 1번 로터를 역순으로 통과하며 문자를 다시 치환합니다.
        -   **플러그보드 (2차)**: 문자가 플러그보드에 연결되어 있으면 다시 교환합니다.
    3.  한 문자의 처리가 끝나면 로터 위치를 업데이트합니다. (첫 번째 로터는 항상 회전, 특정 조건에서 다음 로터도 회전)
    4.  모든 문자에 대한 처리가 끝나면 결과 문자열을 반환합니다.

## 실행 방법

스크립트를 직접 실행하면 미리 정의된 메시지와 설정을 사용하여 암호화 및 복호화 과정을 시연하고, 원본 메시지가 올바르게 복원되는지 확인합니다.

```bash
python enigma_machine2.py
```

**실행 결과:**
```
Encrypted message: YLBHX...
Decrypted message: THIS IS MY PYTHON SCRIPT THAT EMULATES THE ENIGMA MACHINE FROM WWII.
```

## 코드 개선 제안

1.  **객체 지향적 설계**: 현재 코드는 함수 중심으로 작성되어 있습니다. 에니그마의 각 구성 요소(로터, 반사판, 플러그보드)를 별도의 클래스로 만들고, 이들을 조합하여 `EnigmaMachine` 클래스를 만들면 코드의 구조가 더 명확해지고 실제 기계의 동작과 유사해집니다.

    ```python
    # 개선 제안 예시
    class Rotor:
        def __init__(self, wiring, position=0):
            self.wiring = wiring
            self.position = position
        
        def forward(self, char_index):
            # ...
        
        def backward(self, char_index):
            # ...

        def rotate(self):
            # ...

    class EnigmaMachine:
        def __init__(self, rotor_selection, rotor_positions, plugboard_settings):
            # ...
    ```

2.  **로터 회전 메커니즘**: 현재 구현에서 로터 회전은 첫 번째 로터가 한 바퀴 돌면 두 번째 로터가, 두 번째 로터가 한 바퀴 돌면 세 번째 로터가 회전하는 방식으로 단순화되어 있습니다. 실제 에니그마는 "노치(notch)" 메커니즘을 사용하여 특정 위치에서 다음 로터를 회전시키고, "이중 스테핑(double-stepping)"과 같은 더 복잡한 동작을 합니다. 이를 구현하면 시뮬레이션의 정확도가 높아집니다.

3.  **`_plugboard` 함수의 공백 처리**: `pbstring.replace(" ", "")`는 반환값을 사용하지 않아 실제로는 아무런 효과가 없습니다. 문자열은 불변(immutable)이므로 `pbstring = pbstring.replace(" ", "")`와 같이 재할당해야 합니다.

4.  **상수 관리**: 로터 배선과 같은 상수 데이터는 별도의 설정 파일(예: JSON)로 분리하여 관리하면 코드가 더 깔끔해지고, 새로운 로터를 추가하거나 수정하기 용이해집니다.

5.  **타입 힌트 활용**: `RotorPositionT`, `RotorSelectionT`와 같이 타입 힌트를 잘 사용하고 있습니다. `_plugboard` 함수의 반환 타입 힌트(`dict[str, str]`)를 추가하는 등 일관성을 유지하면 좋습니다.
