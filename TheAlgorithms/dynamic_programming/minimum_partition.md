# 최소 부분집합 합의 차이 (Minimum Partition)

이 문서는 `minimum_partition.py` 파일에 구현된 **최소 부분집합 합의 차이**를 구하는 알고리즘에 대해 설명합니다.

## 문제 개요

주어진 정수 집합을 두 개의 부분집합으로 나누었을 때, 각 부분집합의 원소 합의 차이가 최소가 되도록 하는 문제입니다.

예를 들어, 집합 `{1, 6, 11, 5}`가 주어졌을 때:
- 부분집합 1: `{1, 5, 6}` (합: 12)
- 부분집합 2: `{11}` (합: 11)
- 차이: `|12 - 11| = 1` (이것이 최소 차이입니다.)

## 알고리즘: 동적 계획법 (Dynamic Programming)

이 문제는 **부분집합 합 문제(Subset Sum Problem)**의 변형으로 해결할 수 있습니다. 전체 원소의 합을 `s`라고 할 때, 한 부분집합의 합이 `s/2`에 가장 가까운 값을 가지면 두 부분집합의 차이가 최소가 됩니다.

### 주요 함수: `findMin(arr)`

- **매개변수**: `arr` (정수 리스트)
- **반환값**: 두 부분집합 합의 최소 차이 (`diff`)

### 동작 원리

1. **초기화**:
   - 전체 합 `s`와 원소 개수 `n`을 구합니다.
   - `(n + 1) x (s + 1)` 크기의 DP 테이블을 생성하고 `False`로 초기화합니다.
   - `dp[i][j]`는 처음 `i`개의 원소를 사용하여 합 `j`를 만들 수 있는지를 나타냅니다.
   - 합이 0인 경우는 항상 가능하므로 `dp[i][0]`을 `True`로 설정합니다.

2. **DP 테이블 채우기**:
   - 이중 반복문을 통해 모든 원소와 가능한 합에 대해 가능 여부를 검사합니다.
   - **로직**:
     - 현재 원소 `arr[i-1]`을 사용하여 합 `j`를 만들 수 있는지 확인합니다.
     - *참고*: 현재 코드의 `dp[i][j] = dp[i][j - 1]` 부분은 일반적인 알고리즘(`dp[i][j] = dp[i-1][j]`)과 다르게 작성되어 있어 확인이 필요합니다. 일반적으로는 이전 단계(`i-1`)에서 합 `j`를 만들 수 있었거나, 이전 단계에서 합 `j - arr[i-1]`을 만들 수 있었다면 현재 단계에서도 가능하다고 판단합니다.

3. **최소 차이 계산**:
   - `s/2`부터 0까지 역순으로 탐색하며, `dp[n][j]`가 `True`인 첫 번째 `j`를 찾습니다.
   - 이 `j`는 가능한 부분집합의 합 중 `s/2`에 가장 가까운 값(즉, 가능한 최대 합)입니다.
   - 다른 부분집합의 합은 `s - j`가 되므로, 두 합의 차이는 `(s - j) - j = s - 2*j`가 됩니다.

## 시간 복잡도

- **시간 복잡도**: $O(n \cdot s)$ (n은 원소의 개수, s는 원소들의 총합)
- **공간 복잡도**: $O(n \cdot s)$ (DP 테이블 크기)
