# 배낭 문제 (Knapsack Problem)

이 문서는 `knapsack.py` 파일에 구현된 **0/1 배낭 문제(0/1 Knapsack Problem)** 알고리즘에 대해 설명합니다.

## 개요

배낭 문제는 조합 최적화의 유명한 문제로, 일정 무게 제한($W$)이 있는 배낭에 가치와 무게가 있는 아이템들을 넣을 때, 배낭에 담긴 아이템들의 가치 합이 최대가 되도록 하는 문제입니다. 0/1 배낭 문제는 아이템을 쪼갤 수 없으며, 넣거나(1) 넣지 않거나(0)의 선택만 가능합니다.

## 주요 함수 설명

### `MF_knapsack(i, wt, val, j)`
- **목적**: 메모리 함수(Memory Function)를 사용하여 Top-Down 방식(재귀 + 메모이제이션)으로 문제를 해결합니다.
- **매개변수**:
  - `i`: 고려 중인 아이템의 수 (인덱스).
  - `wt`: 무게 리스트.
  - `val`: 가치 리스트.
  - `j`: 현재 남은 배낭 용량.
- **특징**: 전역 변수 `F` 테이블을 사용하여 이미 계산된 하위 문제의 결과를 저장하고 재사용합니다. 필요한 하위 문제만 계산하므로 효율적일 수 있습니다.

### `knapsack(W, wt, val, n)`
- **목적**: Bottom-Up 방식(Tabulation)으로 DP 테이블을 채워 문제를 해결합니다.
- **매개변수**:
  - `W`: 배낭의 최대 용량.
  - `wt`: 무게 리스트.
  - `val`: 가치 리스트.
  - `n`: 아이템의 개수.
- **반환값**: (최대 가치, DP 테이블)
- **알고리즘**:
  - `(n+1) x (W+1)` 크기의 2차원 배열 `dp`를 생성합니다.
  - 아이템을 하나씩 늘려가며, 각 용량에 대해 최대 가치를 계산합니다.
  - 점화식: `dp[i][w] = max(val[i-1] + dp[i-1][w-wt[i-1]], dp[i-1][w])` (아이템을 넣는 경우와 안 넣는 경우 중 큰 값 선택)

### `knapsack_with_example_solution(W, wt, val)`
- **목적**: 최대 가치뿐만 아니라, 실제로 선택된 아이템들의 집합(인덱스)을 반환합니다.
- **동작**:
  1. 입력값(무게와 가치 리스트의 길이, 타입 등)을 검증합니다.
  2. `knapsack` 함수를 호출하여 DP 테이블을 얻습니다.
  3. `_construct_solution` 함수를 호출하여 DP 테이블을 역추적해 선택된 아이템들을 찾아냅니다.

### `_construct_solution(dp, wt, i, j, optimal_set)`
- **목적**: 완성된 DP 테이블을 역추적하여 최적해를 구성하는 아이템들을 찾습니다.
- **로직**:
  - `dp[i][j]` 값이 `dp[i-1][j]` 값보다 크다면, $i$번째 아이템이 배낭에 포함된 것입니다.
  - 포함된 경우 `optimal_set`에 추가하고, 남은 용량(`j - wt[i-1]`)으로 이동하여 계속 추적합니다.

## 사용법

`if __name__ == "__main__":` 블록에서 사용 예시를 확인할 수 있습니다:

1. 아이템의 가치(`val`)와 무게(`wt`), 배낭 용량(`w`)을 정의합니다.
2. `knapsack` 함수를 호출하여 최대 가치를 계산합니다.
3. `MF_knapsack` 함수를 호출하여 동일한 결과를 얻는지 확인합니다. (주의: `MF_knapsack` 사용 전 전역 변수 `F` 초기화 필요)
4. `knapsack_with_example_solution`을 호출하여 최대 가치와 선택된 아이템 목록을 확인합니다.

```python
val = [3, 2, 4, 4]
wt = [4, 3, 2, 3]
w = 6
# 결과: 최대 가치 8, 선택된 아이템 인덱스 {3, 4} (1-based index 기준 3번째, 4번째 아이템)
```
