# 편집 거리 (Edit Distance)

이 문서는 `edit_distance.py` 파일에 구현된 **편집 거리(Edit Distance)** 알고리즘에 대해 설명합니다. 편집 거리 알고리즘은 두 문자열이 얼마나 유사한지를 정량화하는 방법으로, 하나의 문자열을 다른 문자열로 변환하기 위해 필요한 최소 연산 횟수를 계산합니다.

## 개요

주어진 두 문자열 $A$와 $B$에 대해, 다음 세 가지 연산을 사용하여 $A$를 $B$로 바꿀 때 필요한 최소 횟수를 구합니다.
1. **삽입 (Insertion)**
2. **삭제 (Removal/Deletion)**
3. **대체 (Substitution)**

이 파일은 두 가지 방식(Top-Down, Bottom-Up)으로 동적 계획법(Dynamic Programming)을 구현하고 있습니다.

## 클래스: `EditDistance` (Top-Down 방식)

이 클래스는 **재귀(Recursion)**와 **메모이제이션(Memoization)**을 사용하여 문제를 해결합니다.

### `__init__(self)` / `__prepare__(self, N, M)`
- DP 테이블(`self.dp`)을 초기화합니다. 아직 계산되지 않은 상태를 나타내기 위해 `-1`로 채웁니다.

### `solve(self, A, B)`
- **목적**: 사용자 인터페이스 역할을 하며, 입력을 처리하고 재귀 호출을 시작합니다.
- **동작**: 입력 문자열을 저장하고 `__prepare__`를 호출하여 테이블을 초기화한 뒤, `__solveDP`를 호출하여 결과를 반환합니다.

### `__solveDP(self, x, y)`
- **목적**: 문자열 $A$의 $x$번째 인덱스와 $B$의 $y$번째 인덱스까지의 편집 거리를 계산하는 재귀 함수입니다.
- **로직**:
  - **기저 사례**: 한쪽 문자열이 비어있으면($-1$), 다른 쪽 문자열의 남은 길이만큼 연산(삽입/삭제)이 필요하므로 인덱스 $+ 1$을 반환합니다.
  - **메모이제이션**: `self.dp[x][y]`가 `-1`보다 크면 이미 계산된 값이므로 바로 반환합니다.
  - **점화식**:
    - 문자가 같으면: 비용 증가 없이 이전 상태(`x-1`, `y-1`)의 값을 가져옵니다.
    - 문자가 다르면: 삽입, 삭제, 대체 중 가장 비용이 적은 것에 1을 더한 값을 저장합니다.

## 함수: `min_distance_bottom_up(word1, word2)` (Bottom-Up 방식)

이 함수는 **반복문(Iteration)**을 사용하여 작은 문제부터 차례대로 테이블을 채워나가는 방식(Tabulation)입니다.

### 동작 원리
1. `(m+1) x (n+1)` 크기의 2차원 배열 `dp`를 생성합니다.
2. **초기화**: 첫 행과 첫 열은 각각 빈 문자열과의 거리이므로 인덱스 값(0, 1, 2...)으로 초기화합니다.
3. **테이블 채우기**:
   - 문자가 같으면: 대각선 위(`dp[i-1][j-1]`) 값을 그대로 가져옵니다.
   - 문자가 다르면: 왼쪽(`삽입`), 위쪽(`삭제`), 대각선 위(`대체`) 값 중 최솟값에 1을 더합니다.
4. 최종적으로 `dp[m][n]`을 반환합니다.

## 사용법

`if __name__ == "__main__":` 블록에서 사용 예시를 확인할 수 있습니다:

1. `EditDistance` 클래스의 인스턴스를 생성합니다.
2. 사용자로부터 두 개의 문자열을 입력받습니다.
3. 클래스 기반의 `solve` 메서드와 함수 기반의 `min_distance_bottom_up`을 각각 호출하여 결과를 출력합니다.

두 방식 모두 동일한 최소 편집 거리를 계산해야 합니다.
