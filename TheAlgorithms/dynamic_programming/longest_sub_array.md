# 최대 연속 부분 배열 합 (Maximum Contiguous Subarray Sum)

이 문서는 `longest_sub_array.py` 파일에 구현된 **최대 연속 부분 배열 합** 문제 해결 알고리즘에 대해 설명합니다. 이 문제는 주어진 배열에서 연속된 부분 배열의 합 중 가장 큰 값을 찾는 고전적인 동적 계획법(Dynamic Programming) 문제입니다.

## 개요

이 알고리즘은 **카데인 알고리즘(Kadane's Algorithm)**과 유사한 방식으로 동작합니다. 배열을 순회하면서 각 위치에서 끝나는 부분 배열의 최대 합을 계산하고, 이 값들 중 전체 최댓값을 찾아냅니다.

## 클래스: `SubArray`

### `__init__(self, arr)`
- **목적**: 클래스를 초기화합니다.
- **매개변수**:
  - `arr`: 쉼표(`,`)로 구분된 숫자 문자열.
- **동작**: 입력받은 문자열을 쉼표 기준으로 분리하여 숫자 리스트로 변환하고 `self.array`에 저장합니다.

### `solve_sub_array(self)`
- **목적**: 최대 연속 부분 배열의 합을 계산하여 반환합니다.
- **알고리즘 동작 원리**:
  1. **초기화**:
     - `sum_value`: `sum_value[i]`는 인덱스 `i`에서 끝나는 부분 배열의 최대 합을 저장합니다.
     - `rear`: `rear[i]`는 인덱스 `i`까지 탐색했을 때의 전체 최대 합을 저장합니다.
     - 두 배열 모두 첫 번째 원소 값으로 초기화됩니다.
  2. **반복 및 계산**:
     - 배열의 두 번째 원소부터 끝까지 순회합니다.
     - **점화식**: 현재 위치(`i`)에서 끝나는 최대 합은 다음 두 값 중 더 큰 값입니다.
       1. 현재 원소 `array[i]`
       2. 이전 위치에서 끝나는 최대 합 `sum_value[i-1]` + 현재 원소 `array[i]`
       - `sum_value[i] = max(int(self.array[i]) + sum_value[i - 1], int(self.array[i]))`
     - **전체 최댓값 갱신**: 현재까지의 전체 최댓값(`rear[i-1]`)과 방금 계산한 `sum_value[i]`를 비교하여 더 큰 값으로 `rear[i]`를 갱신합니다.
  3. **결과 반환**:
     - `rear` 배열의 마지막 원소가 전체 배열의 최대 부분 배열 합이므로 이 값을 반환합니다.

## 사용법

`if __name__ == "__main__":` 블록에서 사용 예시를 확인할 수 있습니다.
1. 사용자로부터 쉼표로 구분된 숫자들을 입력받습니다.
2. `SubArray` 클래스의 인스턴스를 생성합니다.
3. `solve_sub_array` 메서드를 호출하여 결과를 계산하고 출력합니다.

## 참고 사항

- **공간 복잡도**: 이 구현은 `rear`와 `sum_value` 두 개의 추가 배열을 사용하여 $O(N)$의 공간 복잡도를 가집니다. 카데인 알고리즘은 두 개의 변수만 사용하여 $O(1)$ 공간 복잡도로 최적화할 수 있습니다.
- **가독성**: `rear`와 같은 변수명은 `global_max` 또는 `max_so_far`와 같이 더 명확한 이름으로 개선할 수 있습니다.
