# 1로 만드는 최소 단계 (Minimum Steps to One)

이 문서는 `minimum_steps_to_one.py` 파일에 구현된 **1로 만드는 최소 단계** 알고리즘에 대해 설명합니다. 이 문제는 주어진 정수 $n$을 1로 만들기 위해 필요한 최소 연산 횟수를 구하는 동적 계획법(Dynamic Programming) 문제입니다.

## 문제 개요

정수 $n$에 대해 다음과 같은 세 가지 연산을 수행할 수 있습니다:
1. 1을 뺍니다. ($n \rightarrow n-1$)
2. $n$이 2로 나누어떨어지면 2로 나눕니다. ($n \rightarrow n/2$)
3. $n$이 3으로 나누어떨어지면 3으로 나눕니다. ($n \rightarrow n/3$)

이 연산들을 적절히 조합하여 $n$을 1로 만드는 최소 횟수를 구합니다.

## 주요 함수: `min_steps_to_one(number)`

### `min_steps_to_one(number: int) -> int`
- **목적**: 정수 `number`를 1로 만드는 최소 단계 수를 반환합니다.
- **매개변수**:
  - `number`: 양의 정수.
- **반환값**: 최소 단계 수.
- **예외 처리**: `number`가 0 이하일 경우 `ValueError`를 발생시킵니다.

### 알고리즘 동작 원리 (Tabulation)

이 알고리즘은 **상향식(Bottom-Up)** 동적 계획법을 사용합니다. 1부터 시작하여 `number`까지 각 숫자에 도달하는 최소 단계 수를 계산하여 테이블에 저장합니다.

1. **테이블 초기화**:
   - `table` 리스트를 생성합니다. 크기는 `number + 1`이며, 초기값은 충분히 큰 값(`number + 1`)으로 설정합니다.
   - `table[1] = 0`: 1은 이미 1이므로 0단계가 필요합니다.

2. **반복 및 상태 전이**:
   - `i`를 1부터 `number - 1`까지 반복합니다. 현재 숫자 `i`에서 다음 단계로 갈 수 있는 경우를 계산하여 테이블을 갱신합니다.
   - **1 더하기 (역연산)**: `i`에서 1을 더해 `i+1`로 가는 경우입니다. (원래 문제에서는 1을 빼는 연산에 해당)
     - `table[i + 1] = min(table[i + 1], table[i] + 1)`
   - **2 곱하기 (역연산)**: `i * 2`가 `number`보다 작거나 같으면, `i`에서 2를 곱해 `i*2`로 가는 경우입니다. (원래 문제에서는 2로 나누는 연산에 해당)
     - `table[i * 2] = min(table[i * 2], table[i] + 1)`
   - **3 곱하기 (역연산)**: `i * 3`이 `number`보다 작거나 같으면, `i`에서 3을 곱해 `i*3`으로 가는 경우입니다. (원래 문제에서는 3으로 나누는 연산에 해당)
     - `table[i * 3] = min(table[i * 3], table[i] + 1)`

3. **결과 반환**:
   - 반복이 끝나면 `table[number]`에 `number`를 1로 만드는 최소 단계 수가 저장되어 있으므로 이를 반환합니다.

## 사용법

`if __name__ == "__main__":` 블록은 `doctest`를 실행하여 함수가 올바르게 동작하는지 검증합니다.

예시:
```python
min_steps_to_one(10)
# 결과: 3 (10 -> 9 -> 3 -> 1)
```
