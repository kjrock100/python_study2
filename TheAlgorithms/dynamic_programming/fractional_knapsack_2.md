# 분할 가능한 배낭 문제 (Fractional Knapsack Problem)

이 문서는 `fractional_knapsack_2.py` 파일에 구현된 **분할 가능한 배낭 문제(Fractional Knapsack Problem)** 알고리즘에 대해 설명합니다. 이 문제는 물건을 쪼갤 수 있다고 가정하여, 배낭의 용량을 초과하지 않으면서 담을 수 있는 물건들의 가치 합을 최대화하는 문제입니다.

## 개요

일반적인 0/1 배낭 문제(물건을 쪼갤 수 없음)는 동적 계획법(Dynamic Programming)을 사용해야 하지만, 물건을 쪼갤 수 있는 이 문제는 **탐욕 알고리즘(Greedy Algorithm)**을 사용하여 효율적으로 해결할 수 있습니다. 무게 대비 가치(가성비)가 높은 물건부터 차례대로 담는 방식입니다.

## 주요 함수: `fractional_knapsack`

### `fractional_knapsack(value, weight, capacity)`
- **목적**: 주어진 용량 내에서 최대 가치를 얻을 수 있도록 물건을 선택(또는 분할)합니다.
- **매개변수**:
  - `value`: 각 물건의 가치를 담은 리스트 (`list[int]`).
  - `weight`: 각 물건의 무게를 담은 리스트 (`list[int]`).
  - `capacity`: 배낭이 버틸 수 있는 최대 무게 (`int`).
- **반환값**:
  - `max_value`: 배낭에 담은 물건들의 총 가치 (`float`).
  - `fractions`: 각 물건이 배낭에 담긴 비율을 나타내는 리스트 (`list[float]`). (1이면 전체, 0.5면 절반)

### 알고리즘 동작 원리

1. **비율 계산**: 각 물건의 무게 대비 가치(`value / weight`)를 계산합니다.
2. **정렬**: 이 비율이 높은 순서대로 물건들의 인덱스를 정렬합니다.
3. **배낭 채우기**:
   - 정렬된 순서대로 물건을 확인합니다.
   - **전체 포함 가능**: 현재 물건의 무게가 남은 용량보다 작거나 같다면, 물건을 통째로(`1.0`) 담고 용량을 줄입니다.
   - **부분 포함**: 현재 물건의 무게가 남은 용량보다 크다면, 남은 용량만큼만 비율(`capacity / weight`)을 계산하여 담고 반복을 종료합니다.

## 사용법

`if __name__ == "__main__":` 블록은 `doctest`를 실행하여 함수가 올바르게 동작하는지 검증합니다.

예시:
```python
value = [1, 3, 5, 7, 9]
weight = [0.9, 0.7, 0.5, 0.3, 0.1]
capacity = 5

max_val, fracs = fractional_knapsack(value, weight, capacity)
# 결과: (25, [1, 1, 1, 1, 1])
# 설명: 모든 물건을 다 담아도 용량이 충분하므로 전부 담습니다.
```

## 참고 사항

- 입력 리스트 `value`와 `weight`의 길이는 같아야 합니다.
- `capacity`가 음수일 경우에 대한 처리는 논리적으로 맞지 않지만(무게가 음수가 될 수 없음), 코드상으로는 계산이 수행되어 음수 결과가 나올 수 있습니다.
