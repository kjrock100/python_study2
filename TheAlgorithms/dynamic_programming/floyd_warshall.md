# 플로이드-워셜 알고리즘 (Floyd-Warshall Algorithm)

이 문서는 `floyd_warshall.py` 파일에 구현된 **플로이드-워셜(Floyd-Warshall)** 알고리즘에 대해 설명합니다. 이 알고리즘은 그래프 내의 **모든 정점 쌍(All Pairs)** 간의 최단 경로를 구하는 알고리즘입니다.

## 개요

플로이드-워셜 알고리즘은 동적 계획법(Dynamic Programming)을 기반으로 하며, 중간에 거쳐가는 정점(`k`)을 하나씩 추가하면서 최단 거리를 갱신하는 방식으로 동작합니다. 시간 복잡도는 $O(N^3)$으로, 정점의 수가 적을 때 유용합니다.

## 클래스: `Graph`

### `__init__(self, N=0)`
- **목적**: $N$개의 정점을 가진 그래프를 초기화합니다.
- **주요 변수**:
  - `self.N`: 정점의 개수.
  - `self.dp`: 최단 거리를 저장할 2차원 배열(행렬). 초기값은 무한대(`math.inf`)로 설정됩니다.
  - `self.W`: 가중치 인접 행렬로 초기화되지만, 이 코드에서는 `self.dp`가 직접 업데이트되므로 실제로는 사용되지 않습니다.

### `addEdge(self, u, v, w)`
- **목적**: 정점 `u`에서 `v`로 가는 가중치 `w`인 간선을 추가합니다.
- **동작**: `self.dp[u][v]`에 가중치 `w`를 저장합니다.

### `floyd_warshall(self)`
- **목적**: 모든 정점 쌍 사이의 최단 거리를 계산합니다.
- **알고리즘**:
  - 3중 반복문을 사용합니다.
    - `k`: 거쳐가는 중간 정점 (0 ~ N-1)
    - `i`: 출발 정점 (0 ~ N-1)
    - `j`: 도착 정점 (0 ~ N-1)
  - **점화식**: `self.dp[i][j] = min(self.dp[i][j], self.dp[i][k] + self.dp[k][j])`
  - 즉, `i`에서 `j`로 직접 가는 거리와 `k`를 거쳐서 가는 거리 중 더 짧은 값을 선택하여 갱신합니다.

### `showMin(self, u, v)`
- **목적**: 계산된 `u`에서 `v`까지의 최단 거리를 반환합니다.

## 사용법

`if __name__ == "__main__":` 블록에서 사용 예시를 확인할 수 있습니다:

1. 5개의 정점을 가진 그래프를 생성합니다.
2. `addEdge`를 사용하여 여러 간선과 가중치를 추가합니다.
3. `floyd_warshall()`을 호출하여 모든 경로의 최단 거리를 계산합니다.
4. `showMin`을 통해 특정 경로(예: 1->4, 0->3)의 최단 거리를 출력합니다.

```python
graph = Graph(5)
graph.addEdge(0, 2, 9)
# ... 간선 추가 ...
graph.floyd_warshall()
graph.showMin(1, 4) # 결과 출력
```

## 참고 사항

- **초기화**: 일반적인 플로이드-워셜 구현에서는 자기 자신으로 가는 거리(`dp[i][i]`)를 0으로 초기화하지만, 이 코드에서는 `math.inf`로 초기화되어 있습니다.
