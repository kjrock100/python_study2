# 비인접 요소의 최대 합 (Maximum Non-Adjacent Sum)

이 문서는 `max_non_adjacent_sum.py` 파일에 구현된 **비인접 요소의 최대 합** 알고리즘에 대해 설명합니다. 이 문제는 주어진 정수 배열에서 서로 인접하지 않은 요소들의 합 중 최댓값을 찾는 고전적인 동적 계획법(Dynamic Programming) 문제입니다.

## 개요

배열을 한 번만 순회하면서, 각 단계에서 '현재 요소를 포함하는 경우의 최대 합'과 '현재 요소를 포함하지 않는 경우의 최대 합'을 계속 갱신하여 최종 결과를 도출합니다.

## 주요 함수: `maximum_non_adjacent_sum`

### `maximum_non_adjacent_sum(nums: list[int]) -> int`
- **목적**: 주어진 정수 리스트 `nums`에서 인접하지 않은 요소들의 합의 최댓값을 반환합니다.
- **매개변수**:
  - `nums`: 정수 리스트.
- **반환값**: 비인접 요소들의 최대 합.

### 알고리즘 동작 원리 (O(1) 공간 복잡도)

1. **초기화**:
   - `max_including`: 첫 번째 요소를 **포함하는** 경우의 최대 합. `nums[0]`으로 초기화합니다.
   - `max_excluding`: 첫 번째 요소를 **포함하지 않는** 경우의 최대 합. `0`으로 초기화합니다.

2. **반복 및 상태 전이**:
   - 배열의 두 번째 요소부터 끝까지 순회하며 다음을 계산합니다.
   - **새로운 `max_including`**: 현재 요소(`num`)를 포함하려면, 바로 이전 요소는 포함할 수 없습니다. 따라서 `이전의 max_excluding + num`이 됩니다.
   - **새로운 `max_excluding`**: 현재 요소(`num`)를 포함하지 않으려면, 이전 요소를 포함했거나 포함하지 않았을 수 있습니다. 두 경우 중 더 큰 값을 선택합니다. 즉, `max(이전의 max_including, 이전의 max_excluding)`가 됩니다.
   - 이 두 값을 동시에 갱신합니다.

3. **결과 반환**:
   - 반복이 끝난 후, 마지막 요소를 포함한 경우와 포함하지 않은 경우 중 더 큰 값을 반환합니다. (`max(max_including, max_excluding)`)

## 사용법

`if __name__ == "__main__":` 블록은 `doctest`를 실행하여 함수가 올바르게 동작하는지 검증합니다.

예시:
```python
maximum_non_adjacent_sum([1, 5, 3, 7, 2, 2, 6])
# 결과: 18
# 설명: 5 + 7 + 6 = 18
```

## 시간 및 공간 복잡도

- **시간 복잡도**: $O(N)$ (배열을 한 번 순회)
- **공간 복잡도**: $O(1)$ (상수 개의 변수만 사용)
