# 최장 증가 부분 수열 (Longest Increasing Subsequence) - O(N log N)

이 문서는 `longest_increasing_subsequence_o(nlogn).py` 파일에 구현된 **최장 증가 부분 수열(LIS)** 알고리즘에 대해 설명합니다.

## 개요

최장 증가 부분 수열(LIS) 문제는 주어진 수열에서 오름차순으로 정렬된 가장 긴 부분 수열을 찾는 문제입니다. 일반적인 동적 계획법(DP)을 사용하면 $O(N^2)$의 시간이 소요되지만, 이 코드는 **이진 탐색(Binary Search)**을 결합하여 **$O(N \log N)$**의 시간 복잡도로 문제를 해결합니다.

## 주요 함수 설명

### `CeilIndex(v, l, r, key)`
- **목적**: 정렬된 리스트 `v`의 인덱스 `l`과 `r` 사이에서 `key`보다 크거나 같은 값 중 가장 작은 값의 인덱스를 찾습니다.
- **방식**: 이진 탐색(Binary Search)을 사용하여 $O(\log N)$ 시간에 탐색을 수행합니다.
- **역할**: `tail` 배열에서 현재 숫자가 들어갈 위치를 찾는 데 사용됩니다.

### `LongestIncreasingSubsequenceLength(v: list[int]) -> int`
- **목적**: 입력 리스트 `v`의 최장 증가 부분 수열의 길이를 반환합니다.
- **매개변수**:
  - `v`: 정수 리스트.
- **알고리즘 동작 원리**:
  1. **`tail` 배열**: `tail[i]`는 길이가 `i+1`인 증가 부분 수열들 중에서 **가장 작은 마지막 값(End Element)**을 저장합니다. 이 배열은 항상 정렬된 상태를 유지합니다.
  2. **순회**: 입력 리스트 `v`의 각 요소 `v[i]`를 순회합니다.
     - **Case 1**: `v[i]`가 `tail[0]`보다 작다면, 길이 1인 부분 수열의 끝을 더 작은 값으로 갱신할 수 있습니다. (`tail[0] = v[i]`)
     - **Case 2**: `v[i]`가 `tail`의 모든 값보다 크다면(`tail[length-1]`), 현재 가장 긴 부분 수열을 연장할 수 있습니다. `tail`에 `v[i]`를 추가하고 길이를 1 증가시킵니다.
     - **Case 3**: 위 두 경우가 아니라면, `tail` 배열 내에서 `v[i]`보다 크거나 같은 값 중 가장 작은 값을 찾아 `v[i]`로 교체합니다. 이는 같은 길이의 부분 수열을 만들 때 더 작은 끝값을 가짐으로써, 이후에 더 긴 수열을 만들 가능성을 높이는 과정입니다.
  3. **반환**: 최종적으로 계산된 `length`를 반환합니다.

## 시간 복잡도

- **시간 복잡도**: $O(N \log N)$
  - 리스트의 $N$개 요소를 순회하며, 각 요소에 대해 `CeilIndex` 함수(이진 탐색)를 호출하므로 $O(\log N)$이 소요됩니다.
- **공간 복잡도**: $O(N)$
  - `tail` 배열이 최대 $N$개의 요소를 저장할 수 있습니다.

## 사용법

`if __name__ == "__main__":` 블록은 `doctest`를 실행하여 함수가 올바르게 동작하는지 검증합니다.

예시:
```python
LongestIncreasingSubsequenceLength([2, 5, 3, 7, 11, 8, 10, 13, 6])
# 결과: 6 (예: [2, 3, 7, 8, 10, 13])
```
