# 비트마스크를 이용한 작업 할당 (Task Assignment using Bitmask)

이 문서는 `bitmask.py` 파일에 구현된 알고리즘에 대해 설명합니다. 이 코드는 **비트마스크(Bitmask)**와 **동적 계획법(Dynamic Programming)**을 사용하여, 주어진 제약 조건 하에서 사람들에게 작업을 할당하는 모든 경우의 수를 계산합니다.

## 문제 개요

- **입력**:
  - $N$개의 작업 (Tasks)
  - $M$명의 사람 (People)
  - 각 사람이 수행할 수 있는 작업의 목록
- **조건**:
  - 각 사람은 하나의 작업만 수행할 수 있습니다.
  - 각 작업은 한 사람에게만 할당될 수 있습니다.
- **목표**: 모든 사람($M$명)에게 서로 다른 작업을 하나씩 할당하는 경우의 수를 구합니다.

## 클래스: `AssignmentUsingBitmask`

### `__init__(self, task_performed, total)`
- **목적**: DP 테이블과 필요한 변수들을 초기화합니다.
- **매개변수**:
  - `task_performed`: 각 사람이 수행 가능한 작업 목록 (리스트의 리스트).
  - `total`: 전체 작업의 수 ($N$).
- **주요 변수**:
  - `self.dp`: 메모이제이션을 위한 테이블. 크기는 $(2^M) \times (N+1)$입니다.
    - 행(Row): 사람들의 할당 상태를 나타내는 비트마스크.
    - 열(Col): 현재 고려 중인 작업 번호.
  - `self.final_mask`: 모든 사람이 작업을 할당받았을 때의 비트마스크 값 ($2^M - 1$).

### `CountWaysUtil(self, mask, task_no)`
- **목적**: 재귀적으로 경우의 수를 계산하는 핵심 함수입니다.
- **매개변수**:
  - `mask`: 현재까지 작업을 할당받은 사람들의 집합을 나타내는 비트마스크. (예: $j$번째 비트가 1이면 $j$번째 사람은 이미 작업을 받음)
  - `task_no`: 현재 할당 여부를 결정할 작업 번호 (1부터 $N$까지).
- **알고리즘 동작**:
  1. **기저 사례 (Base Cases)**:
     - `mask == self.final_mask`: 모든 사람이 작업을 할당받았습니다. 유효한 경우이므로 **1**을 반환합니다.
     - `task_no > self.total_tasks`: 더 이상 고려할 작업이 없는데 아직 작업을 못 받은 사람이 있습니다. 유효하지 않으므로 **0**을 반환합니다.
  2. **메모이제이션**: `self.dp[mask][task_no]`에 이미 계산된 값이 있다면 그 값을 반환합니다.
  3. **상태 전이 (Recurrence)**:
     - **옵션 1: 현재 작업을 아무에게도 할당하지 않음**:
       - `CountWaysUtil(mask, task_no + 1)`을 호출하여 다음 작업으로 넘어갑니다.
     - **옵션 2: 현재 작업을 수행 가능한 사람에게 할당함**:
       - 현재 작업(`task_no`)을 수행할 수 있는 사람들의 목록(`self.task[task_no]`)을 확인합니다.
       - 해당 사람(`p`)이 아직 작업을 받지 않았다면(`mask` 확인), 그 사람에게 작업을 할당하고 재귀 호출합니다.
       - `CountWaysUtil(mask | (1 << p), task_no + 1)`
  4. **결과 저장**: 계산된 총 경우의 수를 DP 테이블에 저장하고 반환합니다.

### `countNoOfWays(self, task_performed)`
- **목적**: 입력을 처리하고 DP를 시작합니다.
- **동작**:
  - 입력된 `task_performed` (사람 -> 작업 리스트)를 `self.task` (작업 -> 사람 리스트) 형태의 역참조 맵으로 변환합니다.
  - `CountWaysUtil(0, 1)`을 호출하여 계산을 시작합니다. (초기 마스크 0, 1번 작업부터 시작)

## 사용법

`if __name__ == "__main__":` 블록에서 사용 예시를 확인할 수 있습니다:

1. 전체 작업 수 `total_tasks`를 5로 설정합니다.
2. 3명의 사람이 수행할 수 있는 작업 목록을 정의합니다.
   - 사람 0: 작업 1, 3, 4 가능
   - 사람 1: 작업 1, 2, 5 가능
   - 사람 2: 작업 3, 4 가능
3. `countNoOfWays`를 호출하여 가능한 할당 방법의 수를 출력합니다.

```python
total_tasks = 5
task_performed = [[1, 3, 4], [1, 2, 5], [3, 4]]
# 결과: 10
```