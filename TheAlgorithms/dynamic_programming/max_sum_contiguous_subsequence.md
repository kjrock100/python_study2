# 최대 연속 부분 배열 합 (Maximum Contiguous Subarray Sum)

이 문서는 `max_sum_contiguous_subsequence.py` 파일에 구현된 **최대 연속 부분 배열 합** 문제 해결 알고리즘에 대해 설명합니다. 이 문제는 주어진 정수 배열에서 연속된 부분 배열의 합 중 가장 큰 값을 찾는 고전적인 동적 계획법(Dynamic Programming) 문제입니다.

## 개요

이 코드는 **카데인 알고리즘(Kadane's Algorithm)**을 사용하여 $O(N)$의 시간 복잡도와 $O(1)$의 공간 복잡도로 문제를 효율적으로 해결합니다. 배열을 한 번만 순회하면서 각 위치에서 끝나는 부분 배열의 최대 합을 계속 갱신하고, 이 값들 중 전체 최댓값을 찾아냅니다.

## 주요 함수: `max_subarray_sum`

### `max_subarray_sum(nums: list) -> int`
- **목적**: 주어진 정수 리스트 `nums`에서 연속된 부분 배열의 합의 최댓값을 반환합니다.
- **매개변수**:
  - `nums`: 정수 리스트.
- **반환값**: 최대 연속 부분 배열의 합.

### 알고리즘 동작 원리 (카데인 알고리즘)

1. **초기화**:
   - `res`: 전체 최대 합 (결과값). 첫 번째 원소로 초기화합니다.
   - `s`: 현재 위치에서 끝나는 부분 배열의 최대 합. 첫 번째 원소로 초기화합니다.
   - `s_pre`: 바로 이전 위치에서 끝나는 부분 배열의 최대 합. 첫 번째 원소로 초기화합니다.

2. **반복 및 상태 전이**:
   - 배열의 두 번째 원소부터 끝까지 순회합니다.
   - **점화식**: `s = max(nums[i], s_pre + nums[i])`
     - 현재 위치(`i`)에서 끝나는 최대 합(`s`)은 다음 두 값 중 더 큰 값입니다:
       1. 현재 원소 `nums[i]` 값 자체 (새로운 부분 배열 시작).
       2. 이전 위치에서 끝나는 최대 합 `s_pre`에 현재 원소 `nums[i]`를 더한 값 (기존 부분 배열 확장).
   - `s_pre`를 현재 계산된 `s`로 업데이트하여 다음 반복을 준비합니다.
   - **전체 최댓값 갱신**: `res = max(res, s)`
     - 지금까지의 전체 최대 합(`res`)과 방금 계산한 `s`를 비교하여 더 큰 값으로 `res`를 갱신합니다.

3. **결과 반환**:
   - 반복이 끝나면 `res` 값을 반환합니다.

## 사용법

`if __name__ == "__main__":` 블록에서 사용 예시를 확인할 수 있습니다.

```python
nums = [6, 9, -1, 3, -7, -5, 10]
print(max_subarray_sum(nums))
# 출력: 17 (부분 배열 [6, 9, -1, 3]의 합)
```
