# 분할 가능한 배낭 문제 (Fractional Knapsack) - Bisect 활용

이 문서는 `fractional_knapsack.py` 파일에 구현된 **분할 가능한 배낭 문제(Fractional Knapsack Problem)** 알고리즘에 대해 설명합니다. 이 구현은 파이썬의 `bisect` 모듈과 `itertools.accumulate`를 사용하여 효율적으로 구현되었습니다.

## 개요

분할 가능한 배낭 문제는 물건을 쪼개서 담을 수 있다는 점이 0/1 배낭 문제와 다릅니다. 이 문제는 **탐욕 알고리즘(Greedy Algorithm)**을 사용하여 해결하며, 무게 대비 가치(Value per Weight)가 높은 순서대로 물건을 담습니다.

## 주요 함수: `fracKnapsack`

### `fracKnapsack(vl, wt, W, n)`
- **목적**: 주어진 용량 `W` 내에서 최대 가치를 얻을 수 있도록 물건을 선택합니다.
- **매개변수**:
  - `vl`: 각 물건의 가치 리스트.
  - `wt`: 각 물건의 무게 리스트.
  - `W`: 배낭의 최대 용량.
  - `n`: 물건의 개수.
- **반환값**: 배낭에 담긴 물건들의 총 가치 (`float`).

### 알고리즘 동작 원리

1. **정렬 (Sorting)**:
   - 각 물건의 무게 대비 가치(`vl / wt`)를 기준으로 내림차순 정렬합니다.
   - `zip`을 사용하여 가치와 무게를 묶어서 정렬한 뒤 다시 분리합니다.

2. **누적 무게 계산 (Accumulate)**:
   - `itertools.accumulate`를 사용하여 정렬된 물건들의 무게 누적 합(`acc`)을 구합니다.
   - 예: 무게가 `[10, 20, 30]`이면 `acc`는 `[10, 30, 60]`이 됩니다.

3. **이진 탐색 (Bisect)**:
   - `bisect` 함수를 사용하여 배낭 용량 `W`가 누적 무게 리스트 `acc`에서 어느 위치(`k`)에 들어갈지 찾습니다.
   - 인덱스 `k`는 배낭에 온전히 담을 수 있는 물건의 개수를 의미합니다.

4. **가치 계산**:
   - **`k == 0`인 경우**: 코드상으로는 0을 반환합니다. (주의: 첫 번째 물건조차 담을 수 없는 경우 분할해서 담아야 하는데, 이 구현에서는 0으로 처리되는 한계가 있습니다.)
   - **`k != n`인 경우**:
     - 처음 `k`개의 물건은 온전히 담습니다 (`sum(vl[:k])`).
     - `k`번째 물건은 남은 용량만큼만 분할하여 담습니다.
     - 남은 용량: `W - acc[k-1]`
     - 추가 가치: `(남은 용량) * (k번째 물건의 단위 가치)`
   - **`k == n`인 경우**: 모든 물건을 다 담을 수 있으므로 전체 가치의 합을 반환합니다.

## 사용법

`if __name__ == "__main__":` 블록은 `doctest`를 실행하여 함수가 올바르게 동작하는지 검증합니다.

예시:
```python
fracKnapsack([60, 100, 120], [10, 20, 30], 50, 3)
# 결과: 240.0
```

## 참고 사항

- 이 코드는 `k=0`일 때(즉, 배낭 용량이 가장 가성비 좋은 물건의 무게보다 작을 때) 0을 반환하도록 구현되어 있어, 아주 작은 용량에 대해서는 올바른 분할 배낭 문제의 해답(첫 물건의 일부)을 주지 못할 수 있습니다.
