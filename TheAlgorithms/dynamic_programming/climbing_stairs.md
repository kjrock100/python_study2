# 계단 오르기 (Climbing Stairs)

이 문서는 `climbing_stairs.py` 파일에 구현된 **계단 오르기(Climbing Stairs)** 알고리즘에 대해 설명합니다. 이 문제는 리트코드(LeetCode) 70번 문제로 유명하며, 동적 계획법(Dynamic Programming)의 기초적인 예제입니다.

## 문제 개요

$n$개의 계단이 있습니다. 한 번에 1계단 또는 2계단씩 오를 수 있다고 할 때, 정상($n$번째 계단)까지 도달하는 방법의 수는 총 몇 가지인지 구하는 문제입니다.

## 주요 함수: `climb_stairs(n)`

### `climb_stairs(n: int) -> int`
- **목적**: $n$개의 계단을 오르는 서로 다른 방법의 수를 계산하여 반환합니다.
- **매개변수**:
  - `n`: 계단의 개수 (양의 정수).
- **반환값**: 계단을 오르는 방법의 수.
- **예외 처리**: `n`이 양의 정수가 아니면 `AssertionError`를 발생시킵니다.

### 알고리즘 동작 원리

이 문제는 피보나치 수열과 동일한 점화식을 가집니다.

1. **점화식 도출**:
   - $i$번째 계단에 도달하기 위해서는 바로 전 단계가 $i-1$번째 계단이거나 $i-2$번째 계단이어야 합니다.
   - 따라서 $i$번째 계단에 도달하는 방법의 수 $dp[i]$는 다음과 같습니다:
     $$dp[i] = dp[i-1] + dp[i-2]$$

2. **초기화**:
   - `dp` 배열을 생성합니다.
   - `dp[0] = 1`: 0계단을 오르는 방법 (아무것도 안 함) 1가지로 간주하거나, 점화식 계산을 위한 편의상 설정입니다.
   - `dp[1] = 1`: 1계단을 오르는 방법은 1가지입니다.

3. **반복 계산 (Bottom-Up)**:
   - 2부터 $n$까지 반복하며 점화식을 적용하여 값을 채워 나갑니다.

4. **결과 반환**:
   - `dp[n]`을 반환합니다.

## 사용법

`if __name__ == "__main__":` 블록은 `doctest`를 실행하여 함수가 올바르게 동작하는지 검증합니다.

예시:
```python
climb_stairs(3)
# 결과: 3
# 설명: (1+1+1), (1+2), (2+1) 총 3가지 방법
```
