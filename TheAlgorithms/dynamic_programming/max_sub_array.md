# 최대 부분 배열 합 (Maximum Subarray Problem)

이 문서는 `max_sub_array.py` 파일에 구현된 **최대 부분 배열 합** 문제 해결 알고리즘에 대해 설명합니다. 이 문제는 주어진 정수 배열에서 연속된 부분 배열의 합 중 가장 큰 값을 찾는 고전적인 문제입니다.

이 파일에는 두 가지 주요 알고리즘이 구현되어 있습니다:
1. **분할 정복 (Divide and Conquer)** 방식
2. **카데인 알고리즘 (Kadane's Algorithm)**

## 함수 1: `find_max_sub_array` (분할 정복)

### `find_max_sub_array(A, low, high)`
- **방식**: 분할 정복(Divide and Conquer)을 사용하여 $O(n \log n)$ 시간 복잡도로 문제를 해결합니다.
- **동작 원리**:
  1. **분할(Divide)**: 배열을 중앙(`mid`)을 기준으로 두 개의 하위 배열로 나눕니다.
  2. **정복(Conquer)**: 재귀적으로 왼쪽(`left_sum`)과 오른쪽(`right_sum`) 하위 배열 각각에서 최대 부분 배열 합을 구합니다.
  3. **결합(Combine)**: 중앙을 가로지르는 최대 부분 배열 합(`cross_sum`)을 `find_max_cross_sum` 함수를 통해 구합니다.
  4. 세 가지 경우(왼쪽, 오른쪽, 중앙 가로지르기) 중 가장 큰 값을 최종 결과로 반환합니다.

### `find_max_cross_sum(A, low, mid, high)`
- **목적**: 중앙 지점(`mid`)을 포함하여 왼쪽과 오른쪽으로 걸쳐 있는 부분 배열의 최대 합을 구합니다.
- **동작**:
  - 중앙에서부터 왼쪽으로 뻗어나가며 최대 합(`left_sum`)을 찾습니다.
  - 중앙에서부터 오른쪽으로 뻗어나가며 최대 합(`right_sum`)을 찾습니다.
  - 두 합을 더한 값을 반환합니다.

## 함수 2: `max_sub_array` (카데인 알고리즘)

### `max_sub_array(nums: list[int]) -> int`
- **방식**: 동적 계획법의 일종인 카데인 알고리즘(Kadane's Algorithm)을 사용하여 $O(n)$ 시간 복잡도로 문제를 해결합니다.
- **동작 원리**:
  1. **`current`**: 현재 위치에서 끝나는 부분 배열의 최대 합을 저장합니다. 이 값이 음수가 되면 0으로 초기화하여 새로운 부분 배열을 시작합니다.
  2. **`best`**: 지금까지 발견된 전체 최대 합을 저장합니다.
  3. 배열을 한 번 순회하면서 `current`와 `best` 값을 계속 갱신합니다.
  4. 음수만 있는 배열의 경우 0을 반환하여 빈 배열의 합을 최댓값으로 간주합니다.

## 사용법

### `doctest`
- `max_sub_array` 함수에는 `doctest`가 포함되어 있어 함수의 정확성을 검증합니다.

### `if __name__ == "__main__":`
- 이 블록은 분할 정복 방식의 `find_max_sub_array` 함수의 성능을 측정합니다.
- 다양한 크기의 무작위 입력에 대한 실행 시간을 측정하고 `matplotlib`을 사용하여 그래프로 시각화하여 입력 크기에 따른 시간 변화를 보여줍니다.

## 참고 사항

- `find_max_sub_array` 함수 내부에서 `left_sum`, `right_sum`에 사용된 초기값 `-999999999`는 매우 작은 수를 의미하며, `float('-inf')`를 사용하는 것이 더 일반적이고 안전합니다.
- `max_sub_array` 함수가 시간 및 공간 복잡도 면에서 더 효율적이므로 일반적으로 더 선호되는 해결책입니다.
