# 약어 (Abbreviation)

이 문서는 `abbreviation.py` 파일에 구현된 **약어(Abbreviation)** 문제 해결 알고리즘에 대해 설명합니다. 이 문제는 해커랭크(HackerRank)의 동적 계획법(Dynamic Programming) 챌린지 중 하나입니다.

## 문제 개요

두 개의 문자열 `a`와 `b`가 주어졌을 때, 다음 두 가지 연산을 사용하여 문자열 `a`를 문자열 `b`로 변환할 수 있는지 판단합니다.

1. `a`에 있는 소문자를 대문자로 변경합니다 (0개 이상).
2. `a`에 남아있는 나머지 소문자들을 모두 삭제합니다.

## 주요 함수: `abbr(a, b)`

### `abbr(a: str, b: str) -> bool`
- **목적**: 문자열 `a`를 변환하여 `b`와 같게 만들 수 있는지 여부를 반환합니다.
- **매개변수**:
  - `a`: 변환할 원본 문자열 (소문자와 대문자 혼합).
  - `b`: 목표 문자열 (대문자로만 구성).
- **반환값**: 변환 가능하면 `True`, 불가능하면 `False`.

### 알고리즘 동작 원리 (동적 계획법)

`dp[i][j]`는 문자열 `a`의 처음 `i`개 문자를 사용하여 문자열 `b`의 처음 `j`개 문자를 만들 수 있는지를 나타내는 불리언(Boolean) 값입니다.

1. **초기화**:
   - `dp` 테이블을 `(len(a) + 1) x (len(b) + 1)` 크기로 생성하고 모두 `False`로 초기화합니다.
   - `dp[0][0] = True`: 빈 문자열끼리는 서로 일치한다고 봅니다.

2. **상태 전이 (Transitions)**:
   - 이중 반복문을 통해 `a`의 각 문자(`a[i]`)와 `b`의 각 문자(`b[j]`)를 순회합니다.
   - 만약 `dp[i][j]`가 `True`라면 (즉, 현재까지 매칭이 성공했다면), 다음 두 가지 경우를 고려합니다:
     1. **대문자로 변환하여 매칭**:
        - `j < m`이고 `a[i]`를 대문자로 바꾼 것이 `b[j]`와 같다면, `a[i]`를 `b[j]`로 사용할 수 있습니다.
        - `dp[i + 1][j + 1] = True`로 설정합니다.
     2. **소문자 삭제**:
        - `a[i]`가 소문자라면, 이 문자를 삭제할 수 있습니다.
        - `dp[i + 1][j] = True`로 설정합니다. (즉, `b`의 인덱스는 그대로 두고 `a`의 인덱스만 증가)

3. **결과 반환**:
   - 모든 순회가 끝난 후 `dp[n][m]`의 값을 반환합니다. 이는 `a` 전체를 사용하여 `b` 전체를 만들 수 있는지를 나타냅니다.

## 사용법

`if __name__ == "__main__":` 블록은 `doctest`를 실행하여 함수가 올바르게 동작하는지 검증합니다.

예시:
```python
abbr("daBcd", "ABC")
# 결과: True
# 설명: d(삭제), a->A(매칭), B->B(매칭), c->C(매칭), d(삭제) => ABC
```
