# 최장 공통 부분 수열 (Longest Common Subsequence)

이 문서는 `longest_common_subsequence.py` 파일에 구현된 **최장 공통 부분 수열(LCS)** 알고리즘에 대해 설명합니다. LCS 문제는 두 수열(문자열)이 주어졌을 때, 두 수열에 모두 포함되는 부분 수열 중 가장 긴 것을 찾는 문제입니다. 여기서 부분 수열은 원소들의 상대적인 순서는 유지되지만, 반드시 연속적일 필요는 없습니다.

## 개요

예를 들어, "abc"와 "abg"는 "abcdefgh"의 부분 수열입니다.
이 알고리즘은 **동적 계획법(Dynamic Programming)**을 사용하여 LCS의 길이와 실제 수열을 구합니다.

## 주요 함수: `longest_common_subsequence(x, y)`

### `longest_common_subsequence(x: str, y: str)`
- **목적**: 두 문자열 `x`와 `y` 사이의 최장 공통 부분 수열을 찾습니다.
- **매개변수**:
  - `x`: 첫 번째 문자열.
  - `y`: 두 번째 문자열.
- **반환값**:
  - `L[m][n]`: LCS의 길이 (`int`).
  - `seq`: 찾은 LCS 문자열 (`str`).

### 알고리즘 동작 원리

1. **초기화**:
   - 문자열 `x`의 길이를 `m`, `y`의 길이를 `n`으로 둡니다.
   - `(m+1) x (n+1)` 크기의 2차원 배열 `L`을 생성하고 0으로 초기화합니다. `L[i][j]`는 `x`의 처음 `i`글자와 `y`의 처음 `j`글자 사이의 LCS 길이를 저장합니다.

2. **DP 테이블 채우기 (Bottom-Up)**:
   - 이중 반복문을 사용하여 `i`를 1부터 `m`까지, `j`를 1부터 `n`까지 순회합니다.
   - 현재 문자 `x[i-1]`과 `y[j-1]`을 비교합니다.
     - 문자가 같으면 `match = 1`, 다르면 `match = 0`입니다.
   - 점화식: `L[i][j] = max(L[i-1][j], L[i][j-1], L[i-1][j-1] + match)`
     - 이는 왼쪽 값, 위쪽 값, 또는 대각선 값(매칭 여부에 따른 추가) 중 최댓값을 취하는 방식입니다.

3. **역추적 (Backtracking)**:
   - DP 테이블의 끝(`L[m][n]`)에서 시작하여 역으로 추적하며 실제 LCS 문자열을 구성합니다.
   - `i`와 `j`가 0보다 큰 동안 반복합니다:
     - 현재 위치의 값 `L[i][j]`가 대각선 값 `L[i-1][j-1] + match`와 같다면:
       - `match`가 1인 경우(문자가 같은 경우), 해당 문자를 결과 문자열 `seq`의 앞에 추가합니다.
       - `i`와 `j`를 모두 1씩 감소시켜 대각선 방향으로 이동합니다.
     - 그렇지 않고 `L[i][j]`가 위쪽 값 `L[i-1][j]`와 같다면:
       - `i`를 1 감소시켜 위로 이동합니다.
     - 그렇지 않다면:
       - `j`를 1 감소시켜 왼쪽으로 이동합니다.

## 사용법

`if __name__ == "__main__":` 블록에서 사용 예시를 확인할 수 있습니다:

```python
a = "AGGTAB"
b = "GXTXAYB"
ln, subseq = longest_common_subsequence(a, b)
print("len =", ln, ", sub-sequence =", subseq)
# 출력: len = 4 , sub-sequence = GTAB
```
