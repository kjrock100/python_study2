# 서브마스크 순회 (Iterating Through Submasks)

이 문서는 `iterating_through_submasks.py` 파일에 구현된 **서브마스크 순회** 알고리즘에 대해 설명합니다.

## 개요

비트마스크(Bitmask) `m`이 주어졌을 때, `m`의 모든 서브마스크(Submask)를 효율적으로 순회하는 알고리즘입니다. 서브마스크란 원래 마스크 `m`에서 켜져 있는(1인) 비트들의 부분집합으로 구성된 마스크를 의미합니다.

예를 들어, 마스크가 `101`(십진수 5)이라면, 켜져 있는 비트는 0번과 2번 비트입니다. 가능한 서브마스크는 `101`(5), `100`(4), `001`(1)입니다. (이 코드에서는 0은 결과 리스트에 포함하지 않습니다.)

## 주요 함수: `list_of_submasks(mask)`

### `list_of_submasks(mask: int) -> list[int]`
- **목적**: 주어진 `mask`의 모든 서브마스크를 리스트로 반환합니다.
- **매개변수**:
  - `mask`: 양의 정수. (0은 서브마스크가 없다고 가정하여 입력으로 받지 않습니다.)
- **반환값**: 서브마스크들의 리스트.
- **예외 처리**: `mask`가 양의 정수가 아니면 `AssertionError`를 발생시킵니다.

### 알고리즘 동작 원리

이 알고리즘은 비트 연산을 사용하여 매우 효율적으로 서브마스크를 순회합니다.

```python
submask = mask
while submask:
    all_submasks.append(submask)
    submask = (submask - 1) & mask
```

1. **초기화**: `submask`를 입력받은 `mask`로 설정합니다.
2. **반복**: `submask`가 0이 될 때까지 반복합니다.
3. **갱신 (`(submask - 1) & mask`)**:
   - `submask - 1`: 최하위 비트(LSB)를 0으로 만들고 그 아래의 비트들을 모두 1로 만듭니다.
   - `& mask`: 원래 `mask`에 없는 비트들을 제거합니다.
   - 이 연산은 현재 `submask`의 바로 다음(내림차순) 서브마스크를 계산해냅니다.

이 방식은 불필요한 비트 패턴을 건너뛰고 유효한 서브마스크만 방문하므로 효율적입니다.

## 사용법

`if __name__ == "__main__":` 블록은 `doctest`를 실행하여 함수가 올바르게 동작하는지 검증합니다.

예시:
```python
list_of_submasks(13) # 13은 이진수로 1101
# 결과: [13, 12, 9, 8, 5, 4, 1]
```
