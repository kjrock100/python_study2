# 행렬 곱셈 연쇄 순서 (Matrix Chain Multiplication)

이 문서는 `matrix_chain_order.py` 파일에 구현된 **행렬 곱셈 연쇄 순서** 문제 해결 알고리즘에 대해 설명합니다. 이 문제는 여러 행렬을 순차적으로 곱할 때, 곱셈 순서를 어떻게 정해야 스칼라 곱셈 연산 횟수를 최소화할 수 있는지를 찾는 고전적인 동적 계획법(Dynamic Programming) 문제입니다.

## 개요

예를 들어, 세 행렬 A, B, C를 곱할 때 `(AB)C`와 `A(BC)`는 결과적으로 같은 행렬이 되지만, 중간 과정에서의 곱셈 연산 횟수는 다를 수 있습니다. 이 알고리즘은 최적의 곱셈 순서(괄호 묶기)와 그때의 최소 연산 횟수를 찾습니다.

## 주요 함수 설명

### `MatrixChainOrder(array)`
- **목적**: 주어진 행렬 차원 배열에 대해 최소 곱셈 횟수와 최적의 분할 지점을 계산합니다.
- **매개변수**:
  - `array`: 행렬들의 차원을 담은 리스트. 예를 들어 `[p0, p1, p2, ..., pn]`은 $n$개의 행렬 $A_1, A_2, ..., A_n$을 의미하며, 행렬 $A_i$의 차원은 $p_{i-1} \times p_i$입니다.
- **반환값**:
  - `Matrix`: `Matrix[i][j]`는 $A_i$부터 $A_j$까지의 행렬을 곱하는 데 필요한 최소 연산 횟수를 저장하는 2차원 배열입니다.
  - `Sol`: `Sol[i][j]`는 $A_i...A_j$의 곱을 최적으로 만드는 분할 지점 `k`를 저장하는 2차원 배열입니다.
- **알고리즘 동작 원리**:
  1. **초기화**: `Matrix`와 `Sol` 테이블을 0으로 초기화합니다.
  2. **반복**:
     - `ChainLength` (부분 체인의 길이)를 2부터 $n$까지 증가시킵니다.
     - 각 길이에 대해 가능한 모든 부분 체인(`a`부터 `b`까지)을 순회합니다.
     - 각 부분 체인에 대해 최적의 분할 지점 `c`를 찾습니다.
  3. **점화식**:
     - `cost = Matrix[a][c] + Matrix[c+1][b] + array[a-1] * array[c] * array[b]`
     - 이 식은 $(A_a...A_c)(A_{c+1}...A_b)$ 형태로 곱셈을 수행할 때의 총비용을 의미합니다.
     - 기존의 최소 비용보다 `cost`가 더 작으면 `Matrix`와 `Sol` 테이블을 갱신합니다.

### `PrintOptimalSolution(OptimalSolution, i, j)`
- **목적**: `MatrixChainOrder`에서 계산된 `Sol` 테이블을 사용하여 최적의 곱셈 순서(괄호 묶기)를 재귀적으로 출력합니다.
- **동작**:
  - `i == j`이면 행렬 이름(`Ai`)을 출력합니다.
  - 그렇지 않으면, 괄호를 열고 `OptimalSolution[i][j]`를 기준으로 왼쪽과 오른쪽 부분을 재귀적으로 호출한 뒤 괄호를 닫습니다.

## 사용법

`if __name__ == "__main__":` 블록에서 사용 예시를 확인할 수 있습니다:

1. 행렬들의 차원을 나타내는 `array`를 정의합니다.
   - 예: `[30, 35, 15, 5, 10, 20, 25]`는 6개의 행렬(30x35, 35x15, ...)을 의미합니다.
2. `MatrixChainOrder`를 호출하여 최소 연산 횟수와 최적해 테이블을 얻습니다.
3. 최소 연산 횟수(`Matrix[1][n-1]`)를 출력합니다.
4. `PrintOptimalSolution`을 호출하여 최적의 괄호 묶기 결과를 출력합니다.

## 시간 및 공간 복잡도

- **시간 복잡도**: $O(n^3)$ (3중 반복문 사용)
- **공간 복잡도**: $O(n^2)$ (두 개의 2차원 DP 테이블 사용)
