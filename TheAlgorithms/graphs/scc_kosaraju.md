# 코사라주 알고리즘 (Kosaraju's Algorithm)

이 문서는 `scc_kosaraju.py` 파일에 구현된 **코사라주 알고리즘**에 대해 설명합니다.

## 개요

코사라주 알고리즘은 유향 그래프(Directed Graph)에서 **강한 연결 요소(SCC, Strongly Connected Components)**를 찾는 알고리즘입니다. 강한 연결 요소란 그래프 내의 부분 집합으로, 해당 집합에 속한 모든 정점 쌍 $(u, v)$에 대해 $u$에서 $v$로 가는 경로와 $v$에서 $u$로 가는 경로가 모두 존재하는 최대 부분 그래프를 말합니다.

이 알고리즘은 두 번의 깊이 우선 탐색(DFS)을 사용하여 $O(V + E)$의 시간 복잡도로 SCC를 찾습니다.

## 주요 변수

- `graph`: 원본 그래프의 인접 리스트.
- `reversedGraph`: 간선의 방향을 뒤집은 그래프(전치 그래프)의 인접 리스트.
- `stack`: 첫 번째 DFS 수행 시 정점의 탐색 종료 순서대로 저장하는 스택.
- `visit`: 정점 방문 여부를 저장하는 리스트.
- `scc`: 발견된 강한 연결 요소들의 리스트를 저장하는 리스트.
- `component`: 현재 탐색 중인 하나의 강한 연결 요소를 저장하는 리스트.

## 주요 함수

### `dfs(u)`
- **목적**: 첫 번째 DFS 탐색을 수행하여 스택에 정점을 쌓습니다.
- **동작**:
  - 정점 `u`를 방문 처리합니다.
  - `u`에서 갈 수 있는 모든 이웃 정점에 대해 재귀적으로 `dfs`를 호출합니다.
  - `u`의 모든 이웃 탐색이 끝나면 `u`를 `stack`에 추가합니다. (위상 정렬과 유사한 순서)

### `dfs2(u)`
- **목적**: 뒤집힌 그래프(`reversedGraph`)에서 DFS를 수행하여 하나의 SCC를 구성합니다.
- **동작**:
  - 정점 `u`를 방문 처리하고 현재 `component`에 추가합니다.
  - `reversedGraph`에서 `u`와 연결된 이웃 정점들에 대해 재귀적으로 `dfs2`를 호출합니다.

### `kosaraju()`
- **목적**: 전체 알고리즘을 조율하여 모든 SCC를 찾습니다.
- **알고리즘 단계**:
  1. **1차 DFS**: 모든 정점에 대해 `dfs`를 호출하여 `stack`을 채웁니다. 이때 스택에는 탐색이 늦게 끝난 정점일수록 나중에(위쪽에) 쌓입니다.
  2. **방문 초기화**: `visit` 리스트를 초기화합니다.
  3. **2차 DFS**: `stack`에서 정점을 하나씩 꺼내며(LIFO), 아직 방문하지 않은 정점이라면 새로운 SCC의 시작점으로 간주합니다.
     - `component` 리스트를 비우고 `dfs2`를 호출하여 SCC를 찾습니다.
     - 찾은 `component`를 `scc` 결과 리스트에 추가합니다.
  4. 최종적으로 `scc` 리스트를 반환합니다.

## 사용법

`if __name__ == "__main__":` 블록에서 사용자 입력을 받아 그래프를 구성하고 알고리즘을 실행합니다.

**입력 형식**:
1. 첫 줄에 정점의 개수 `n`과 간선의 개수 `m`을 입력합니다.
2. 다음 `m`개의 줄에 간선 정보 `u v` (u에서 v로 가는 간선)를 입력합니다.

**예시**:
```python
# 입력
# 5 5
# 1 0
# 0 2
# 2 1
# 0 3
# 3 4

# 실행 결과 (SCC 리스트)
# [[0, 1, 2], [3], [4]] (순서는 다를 수 있음)
```

## 참고 사항
- 이 구현은 전역 변수(`global`)를 사용하여 상태를 관리하므로, 모듈로 재사용하기보다는 알고리즘 로직을 이해하거나 단일 스크립트로 실행하는 데 적합합니다.
- 정점 번호는 0부터 시작한다고 가정합니다.
