# 탐욕적 최소 정점 덮개 (Greedy Min Vertex Cover)

이 문서는 `greedy_min_vertex_cover.py` 파일에 구현된 **탐욕적 최소 정점 덮개(Minimum Vertex Cover)** 근사 알고리즘에 대해 설명합니다.

## 개요

**정점 덮개(Vertex Cover)**란 그래프의 모든 간선이 적어도 하나의 선택된 정점과 연결되도록 하는 정점들의 집합을 말합니다. **최소 정점 덮개 문제**는 가능한 가장 적은 수의 정점을 선택하여 정점 덮개를 만드는 문제입니다. 이 문제는 NP-Hard 문제로 알려져 있어, 효율적인 시간 내에 최적해를 구하기 어렵습니다. 따라서 이 코드는 **탐욕적(Greedy)** 방법을 사용하여 근사해(Approximate Solution)를 구합니다.

## 주요 함수: `greedy_min_vertex_cover`

### `greedy_min_vertex_cover(graph: dict) -> set[int]`

- **목적**: 주어진 그래프에서 최소 정점 덮개의 근사해를 찾아 반환합니다.
- **매개변수**:
  - `graph`: 인접 리스트 형태의 딕셔너리. (Key: 정점, Value: 이웃 정점 리스트)
- **반환값**: 선택된 정점들의 집합(`set`).

### 알고리즘 동작 원리

1. **우선순위 큐 초기화**:
   - 각 정점의 차수(Degree, 연결된 간선의 수)를 계산합니다.
   - 차수가 높은 정점을 우선적으로 선택하기 위해, `(-차수, (정점, 이웃리스트))` 형태의 튜플을 리스트에 담아 힙(Heap)으로 만듭니다. 파이썬의 `heapq`는 최소 힙이므로, 차수에 `-1`을 곱하여 최대 힙처럼 동작하게 합니다.

2. **탐욕적 선택 루프**:
   - 큐가 비어있지 않고, 가장 차수가 높은 정점의 차수가 0이 아닐 때까지(즉, 간선이 남아있는 동안) 반복합니다.
   - **선택**: 힙에서 가장 차수가 높은 정점(`argmax`)을 꺼내고, 결과 집합(`chosen_vertices`)에 추가합니다.
   - **갱신**: 큐에 남아있는 다른 정점들을 순회하며, 방금 선택된 정점(`argmax`)과 연결된 간선을 제거합니다.
     - 이웃 정점의 인접 리스트에서 `argmax`를 삭제합니다.
     - 이웃 정점의 차수(Rank)를 업데이트합니다 (간선이 하나 줄었으므로).
   - **재정렬**: 갱신된 차수를 반영하기 위해 `heapq.heapify(queue)`를 호출하여 힙을 다시 정렬합니다.

3. **결과 반환**:
   - 모든 간선이 커버되면 선택된 정점들의 집합을 반환합니다.

## 사용법

`if __name__ == "__main__":` 블록에서 `doctest`를 실행하여 코드를 검증하고 예제를 실행합니다.

```python
graph = {
    0: [1, 3],
    1: [0, 3],
    2: [0, 3, 4],
    3: [0, 1, 2],
    4: [2, 3]
}
print(f"Minimum vertex cover:\n{greedy_min_vertex_cover(graph)}")
# 출력 예시: {0, 1, 2, 4} (실행 결과에 따라 다를 수 있음)
```

## 참고 자료
- Wolfram MathWorld: Minimum Vertex Cover
- StackExchange: Greedy algorithm for vertex cover
