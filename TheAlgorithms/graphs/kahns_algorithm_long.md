# 칸의 알고리즘을 이용한 최장 거리 (Longest Distance using Kahn's Algorithm)

이 문서는 `kahns_algorithm_long.py` 파일에 구현된 **칸의 알고리즘(Kahn's Algorithm)**을 사용하여 **유향 비순환 그래프(DAG)**에서 최장 경로의 길이를 구하는 방법에 대해 설명합니다.

## 개요

일반적인 그래프에서 최장 경로를 찾는 문제는 NP-Hard 문제이지만, 사이클이 없는 유향 그래프(DAG)에서는 위상 정렬(Topological Sort)을 이용하여 선형 시간 $O(V+E)$ 안에 해결할 수 있습니다. 이 코드는 위상 정렬 알고리즘 중 하나인 칸의 알고리즘을 변형하여 구현되었습니다.

## 주요 함수: `longestDistance`

### `longestDistance(graph)`

- **목적**: 주어진 DAG에서 가장 긴 경로에 포함된 정점의 개수(또는 거리)를 계산하고 출력합니다.
- **매개변수**:
  - `graph`: 인접 리스트 형태의 딕셔너리. (Key: 정점 인덱스, Value: 이웃 정점 리스트)
- **동작 원리**:
  1. **진입 차수(Indegree) 계산**: 모든 정점에 대해 들어오는 간선의 수를 계산합니다.
  2. **초기화**:
     - `queue`: 진입 차수가 0인 정점들을 저장할 리스트.
     - `longDist`: 각 정점까지의 최장 거리를 저장할 리스트. 모든 값을 1로 초기화합니다 (자기 자신만 포함된 경로의 길이는 1).
  3. **위상 정렬 및 거리 갱신**:
     - 큐에서 정점 `vertex`를 꺼냅니다.
     - `vertex`와 연결된 모든 이웃 정점 `x`에 대해:
       - `x`의 진입 차수를 1 감소시킵니다.
       - 거리 갱신: `longDist[x]`를 `longDist[vertex] + 1`과 비교하여 더 큰 값으로 업데이트합니다. 즉, 현재까지 발견된 `x`로 가는 경로 중 가장 긴 경로를 선택합니다.
       - 만약 `x`의 진입 차수가 0이 되면 큐에 추가합니다.
  4. **결과 출력**: `longDist` 리스트에서 가장 큰 값을 출력합니다.

## 사용법

코드 하단에 예제 그래프 데이터가 포함되어 있으며, 함수를 호출하여 결과를 확인할 수 있습니다.

```python
# 그래프 정의 (인접 리스트)
graph = {
    0: [2, 3, 4],
    1: [2, 7],
    2: [5],
    3: [5, 7],
    4: [7],
    5: [6],
    6: [7],
    7: []
}

# 함수 실행
longestDistance(graph)
```

### 실행 결과 예시
위 그래프에서 최장 경로는 `0 -> 2 -> 5 -> 6 -> 7` 또는 `0 -> 3 -> 5 -> 6 -> 7` 등이 될 수 있으며, 정점의 개수는 5개입니다.

```text
5
```
