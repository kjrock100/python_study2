# 보루브카 알고리즘 (Borůvka's Algorithm)

이 문서는 `boruvka.py` 파일에 구현된 **보루브카 알고리즘**에 대해 설명합니다.

## 개요

보루브카 알고리즘은 연결된 무향 그래프에서 **최소 신장 트리(MST, Minimum Spanning Tree)**를 찾는 그리디 알고리즘입니다. 프림(Prim) 알고리즘이나 크루스칼(Kruskal) 알고리즘과 같은 목적을 가지며, 시간 복잡도는 $O(E \log V)$입니다.

이 알고리즘의 특징은 간선을 미리 정렬하거나 우선순위 큐를 유지할 필요가 없다는 점입니다.

## 주요 클래스: `Graph`

그래프를 표현하고 알고리즘을 수행하는 클래스입니다.

### `__init__(self, num_of_nodes: int)`
- **목적**: 그래프를 초기화합니다.
- **매개변수**: `num_of_nodes` (노드의 개수).
- **속성**:
  - `m_edges`: 간선 리스트 `[u, v, weight]`.
  - `m_component`: 각 노드가 속한 컴포넌트(집합)의 대표 노드를 저장하는 딕셔너리.

### `add_edge(self, u_node: int, v_node: int, weight: int)`
- **목적**: 그래프에 가중치가 있는 간선을 추가합니다.

### `find_component(self, u_node: int) -> int`
- **목적**: 주어진 노드가 속한 컴포넌트의 루트(대표) 노드를 찾습니다. 재귀적으로 부모를 따라가며 찾습니다.

### `union(self, component_size: list[int], u_node: int, v_node: int)`
- **목적**: 두 개의 컴포넌트를 하나로 합칩니다.
- **동작**:
  - 두 컴포넌트의 크기(`component_size`)를 비교하여 더 작은 컴포넌트를 큰 컴포넌트에 붙입니다.
  - 합친 후 `set_component`를 호출하여 컴포넌트 정보를 갱신합니다.

### `boruvka(self)`
- **목적**: 보루브카 알고리즘을 실행하여 MST를 찾고 총 가중치를 출력합니다.
- **알고리즘 동작 과정**:
  1. **초기화**: 모든 노드를 각각 개별적인 컴포넌트로 초기화합니다.
  2. **반복 (While)**: 컴포넌트의 개수가 1개가 될 때까지 반복합니다.
     - **최소 간선 찾기**: 모든 간선을 순회하며, 각 컴포넌트에서 외부로 연결되는 가장 가중치가 작은 간선(`minimum_weight_edge`)을 찾습니다.
     - **간선 선택 및 병합**: 선택된 최소 간선들을 확인합니다.
       - 두 노드가 서로 다른 컴포넌트에 속해 있다면, 해당 간선을 MST에 추가합니다.
       - `union` 함수를 통해 두 컴포넌트를 병합하고, 전체 컴포넌트 개수를 줄입니다.
  3. **결과 출력**: 선택된 간선들과 MST의 총 가중치를 출력합니다.

## 사용법

`test_vector` 함수나 `doctest`를 통해 실행 예시를 확인할 수 있습니다.

```python
g = Graph(8)
# 간선 추가: (u, v, weight)
g.add_edge(0, 1, 10)
g.add_edge(0, 2, 6)
# ... (생략) ...
g.boruvka()
```

## 참고 사항
- 이 구현에서는 `set_component` 함수가 병합 시마다 전체 컴포넌트 딕셔너리를 갱신하므로, 최적화된 Union-Find 자료구조를 사용하는 방식보다는 성능이 떨어질 수 있습니다.
- 공간 복잡도는 노드 수와 간선 수에 비례하는 $O(V + E)$입니다.
