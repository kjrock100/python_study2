# 디닉 알고리즘 (Dinic's Algorithm)

이 문서는 `dinic.py` 파일에 구현된 **디닉 알고리즘**에 대해 설명합니다.

## 개요

디닉 알고리즘은 네트워크 유량(Network Flow) 문제에서 **최대 유량(Maximum Flow)**을 찾는 알고리즘입니다. 에드몬드-카프(Edmonds-Karp) 알고리즘보다 일반적으로 더 빠르며, 레벨 그래프(Level Graph)를 구성하여 차단 유량(Blocking Flow)을 찾는 방식으로 동작합니다.

이 구현은 비트 스케일링(Bit Scaling) 기법을 적용하여 큰 용량을 가진 간선을 우선적으로 처리함으로써 성능을 최적화하고 있습니다.

## 주요 클래스: `Dinic`

### `__init__(self, n)`
- **목적**: 노드 개수 `n`을 받아 그래프와 관련 변수들을 초기화합니다.
- **속성**:
  - `lvl`: 각 노드의 레벨(시작점으로부터의 거리)을 저장하는 리스트.
  - `ptr`: DFS 수행 시 각 노드에서 다음에 탐색할 간선의 인덱스를 저장하는 리스트 (현재 호(Current Arc) 최적화).
  - `q`: BFS를 위한 큐.
  - `adj`: 인접 리스트. 각 간선은 `[이웃 노드, 역방향 간선 인덱스, 용량, 현재 유량]` 형태로 저장됩니다.

### `add_edge(self, a, b, c, rcap=0)`
- **목적**: 노드 `a`에서 `b`로 가는 용량 `c`인 간선을 추가합니다.
- **특징**: 유량 네트워크에서는 역방향 간선(Residual Edge)이 필요하므로, `b`에서 `a`로 가는 용량 `rcap`(기본값 0)인 간선도 함께 생성하여 서로 참조하도록 합니다.

### `depth_first_search(self, vertex, sink, flow)`
- **목적**: 레벨 그래프 상에서 DFS를 수행하여 싱크(Sink)까지의 경로를 찾고 유량을 흘려보냅니다.
- **동작**:
  - 현재 노드에서 갈 수 있는 간선들을 순회하며, 레벨이 1 높은 이웃 노드로 유량을 보냅니다.
  - `ptr`을 사용하여 이미 탐색이 끝난 간선은 다시 보지 않도록 최적화합니다.
  - 경로를 찾으면 해당 경로상의 간선들에 유량을 더하고, 역방향 간선에서는 유량을 뺍니다.

### `max_flow(self, source, sink)`
- **목적**: 소스(Source)에서 싱크(Sink)까지의 최대 유량을 계산합니다.
- **알고리즘 동작**:
  1. **스케일링 루프**: 용량이 큰 간선부터 처리하기 위해 비트 단위로(`1 << 30` 부터) 임계값을 낮춰가며 반복합니다.
  2. **BFS (레벨 그래프 생성)**: 소스에서 시작하여 각 노드의 레벨(`lvl`)을 계산합니다. 이때 잔여 용량이 현재 임계값 이상인 간선만 이용합니다.
  3. **DFS (유량 증가)**: 싱크까지 도달 가능하다면, DFS를 통해 차단 유량을 찾아 흘려보냅니다.
  4. 더 이상 싱크로 갈 수 없을 때까지 반복합니다.

## 사용법

파일 하단에 포함된 예제 코드는 이분 그래프(Bipartite Graph) 형태의 네트워크를 구성하고 최대 유량을 계산합니다.

```python
# 그래프 생성 (노드 10개)
graph = Dinic(10)
source = 0
sink = 9

# 소스 -> 중간 노드들 (용량 1)
for vertex in range(1, 5):
    graph.add_edge(source, vertex, 1)

# ... (중간 노드 연결 및 싱크 연결 생략) ...

# 최대 유량 계산 및 출력
print(graph.max_flow(source, sink))
```