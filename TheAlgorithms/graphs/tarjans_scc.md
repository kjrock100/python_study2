# 타잔 알고리즘 (Tarjan's Algorithm)

이 문서는 `tarjans_scc.py` 파일에 구현된 **타잔 알고리즘(Tarjan's Algorithm)**에 대해 설명합니다.

## 개요

타잔 알고리즘은 유향 그래프(Directed Graph)에서 **강한 연결 요소(SCC, Strongly Connected Components)**를 찾는 효율적인 알고리즘입니다. 코사라주 알고리즘(Kosaraju's Algorithm)이 두 번의 DFS를 수행하는 것과 달리, 타잔 알고리즘은 **한 번의 DFS(깊이 우선 탐색)**만으로 모든 SCC를 찾아낼 수 있습니다.

시간 복잡도는 정점의 수를 $V$, 간선의 수를 $E$라고 할 때 $O(V + E)$입니다.

## 주요 개념

알고리즘은 각 노드에 대해 다음 두 가지 값을 추적합니다.

1. **Index (탐색 순서)**: DFS 수행 중 해당 노드가 몇 번째로 방문되었는지를 나타내는 고유 번호입니다.
2. **Low Link (최소 도달 가능 인덱스)**: 해당 노드에서 시작하여 DFS 트리 상의 자식 노드나 스택에 있는 노드(역방향 간선)를 통해 도달할 수 있는 노드 중 가장 작은 Index 값입니다.

## 주요 함수: `tarjan`

### `tarjan(g)`

- **목적**: 주어진 그래프 `g`에서 모든 강한 연결 요소를 찾아 반환합니다.
- **매개변수**:
  - `g`: 인접 리스트 형태의 그래프. (리스트의 리스트)
- **반환값**: SCC들의 리스트.
- **내부 변수**:
  - `stack`: 현재 탐색 중인 경로상의 노드들을 저장하는 스택. SCC를 형성하는 노드들을 추출할 때 사용됩니다.
  - `on_stack`: 특정 노드가 스택에 있는지 여부를 빠르게 확인하기 위한 리스트.
  - `index_of`: 각 노드의 방문 순서(Index). `-1`이면 아직 방문하지 않음을 의미합니다.
  - `lowlink_of`: 각 노드의 Low Link 값.

### 내부 함수: `strong_connect(v, index, components)`

- **목적**: 실제 DFS를 수행하며 SCC를 식별합니다.
- **동작 원리**:
  1. 현재 노드 `v`의 `index`와 `lowlink`를 설정하고 스택에 넣습니다.
  2. `v`의 모든 이웃 `w`에 대해:
     - **방문하지 않은 경우**: 재귀적으로 `strong_connect`를 호출하고, `v`의 `lowlink`를 `w`의 `lowlink`를 이용하여 갱신합니다. (`lowlink[v] = min(lowlink[v], lowlink[w])`)
     - **스택에 있는 경우**: 역방향 간선이므로, `v`의 `lowlink`를 `w`의 `lowlink`를 이용하여 갱신합니다.
  3. **SCC 루트 확인**: 만약 `lowlink[v] == index[v]`라면, `v`는 SCC의 루트입니다.
     - 스택에서 `v`가 나올 때까지 노드들을 꺼내어 하나의 SCC(`component`)를 구성합니다.
     - 구성된 SCC를 결과 리스트(`components`)에 추가합니다.

## 헬퍼 함수: `create_graph`

- **목적**: 정점 수와 간선 리스트를 입력받아 인접 리스트 형태의 그래프를 생성합니다.

## 사용법

`if __name__ == "__main__":` 블록에서 실행 예시를 확인할 수 있습니다.

```python
n_vertices = 7
source = [0, 0, 1, 2, 3, 3, 4, 4, 6]
target = [1, 3, 2, 0, 1, 4, 5, 6, 5]
edges = [(u, v) for u, v in zip(source, target)]
g = create_graph(n_vertices, edges)

# 결과: [[5], [6], [4], [3, 2, 1, 0]] (순서는 다를 수 있음)
print(tarjan(g))
```

## 코사라주 알고리즘과의 비교
- **타잔 알고리즘**: 1번의 DFS 수행, 스택 1개 사용, 구현이 다소 복잡할 수 있음.
- **코사라주 알고리즘**: 2번의 DFS 수행 (정방향, 역방향), 구현이 직관적임.
- 두 알고리즘 모두 시간 복잡도는 $O(V+E)$로 동일하지만, 실제 실행 속도는 타잔 알고리즘이 상수항 측면에서 조금 더 빠를 수 있습니다.