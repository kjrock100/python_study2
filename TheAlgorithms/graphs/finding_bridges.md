# 단절선 찾기 (Finding Bridges)

이 문서는 `finding_bridges.py` 파일에 구현된 **단절선(Bridge)** 찾기 알고리즘에 대해 설명합니다.

## 개요

그래프 이론에서 **단절선(Bridge)**이란 무향 그래프 내의 간선 중, 해당 간선을 제거했을 때 그래프의 연결 요소(Connected Component)의 개수가 증가하는 간선을 의미합니다. 즉, 그래프의 연결성을 유지하는 데 필수적인 간선입니다.

이 알고리즘은 네트워크 설계 등에서 중요한 연결 고리나 취약점을 찾는 데 사용될 수 있습니다.

## 알고리즘 원리

이 구현은 **깊이 우선 탐색(DFS)**을 기반으로 합니다. 각 정점을 방문할 때마다 고유한 방문 순서(ID)를 부여하고, 해당 정점에서 DFS 트리의 자식 노드들을 통해 도달할 수 있는 가장 작은 ID 값(`low`)을 계산합니다.

특정 간선 `(u, v)`에 대해, `v`가 `u`의 자식 정점일 때 `v`에서 `u` 또는 `u`의 조상으로 가는 역방향 간선(Back-edge)이 없다면, `(u, v)`는 단절선이 됩니다. 이를 수식으로 표현하면 `id(u) < low(v)`가 됩니다.

## 주요 함수

### `compute_bridges(graph: dict[int, list[int]]) -> list[tuple[int, int]]`

- **목적**: 주어진 무향 그래프에서 모든 단절선을 찾아 반환합니다.
- **매개변수**:
  - `graph`: 인접 리스트 형태의 딕셔너리. (Key: 정점, Value: 이웃 정점 리스트)
- **반환값**: 단절선들의 리스트. 각 단절선은 `(u, v)` 튜플 형태이며, `u <= v`로 정렬되어 반환됩니다.

### 내부 함수 `dfs(at, parent, bridges, id)`

- **목적**: DFS를 수행하며 `low` 값을 갱신하고 단절선을 식별합니다.
- **매개변수**:
  - `at`: 현재 탐색 중인 정점.
  - `parent`: DFS 트리에서 현재 정점의 부모 정점.
  - `bridges`: 발견된 단절선을 저장할 리스트.
  - `id`: 현재 정점의 방문 순서 ID.
- **동작**:
  1. 현재 정점 `at`을 방문 처리하고 `low[at]`를 `id`로 설정합니다.
  2. 인접한 정점 `to`를 순회합니다.
     - `to`가 부모 정점(`parent`)이면 무시합니다.
     - `to`가 방문하지 않은 정점이면:
       - 재귀적으로 `dfs`를 호출합니다.
       - 자식 정점의 `low` 값을 이용해 현재 정점의 `low` 값을 갱신합니다 (`low[at] = min(low[at], low[to])`).
       - 만약 `id <= low[to]`라면, 역방향 간선이 없다는 의미이므로 `(at, to)`를 단절선으로 추가합니다.
     - `to`가 이미 방문한 정점이면:
       - 역방향 간선이므로 `low[at]`를 갱신합니다 (`low[at] = min(low[at], low[to])`).

## 사용법

`if __name__ == "__main__":` 블록에서 `doctest`를 실행하여 코드를 검증합니다.

```python
# 예시 그래프 데이터
graph = {
    0: [1, 2],
    1: [0, 2],
    2: [0, 1, 3, 5],
    3: [2, 4],
    4: [3],
    5: [2, 6, 8],
    6: [5, 7],
    7: [6, 8],
    8: [5, 7],
}

bridges = compute_bridges(graph)
print(bridges)
# 출력 예시: [(3, 4), (2, 3), (2, 5)]
```

## 참고 자료
- GeeksforGeeks: Bridge in a graph
