# 최소 신장 트리 - 보루브카 알고리즘 (Minimum Spanning Tree - Boruvka's Algorithm)

이 문서는 `minimum_spanning_tree_boruvka.py` 파일에 구현된 **보루브카 알고리즘**에 대해 설명합니다.

## 개요

보루브카 알고리즘은 가중치가 있는 무향 그래프에서 **최소 신장 트리(MST, Minimum Spanning Tree)**를 찾는 그리디 알고리즘입니다. 이 알고리즘은 가장 오래된 MST 알고리즘 중 하나로, 병렬 처리에 적합한 특성을 가지고 있습니다.

## 주요 클래스: `Graph`

그래프를 표현하고 알고리즘을 실행하는 메인 클래스입니다.

### `__init__(self)`
- 그래프의 정점 수, 간선 수, 인접 리스트(`adjacency`)를 초기화합니다.

### `add_edge(self, head, tail, weight)`
- 두 정점(`head`, `tail`) 사이에 가중치(`weight`)가 있는 무향 간선을 추가합니다.

### `distinct_weight(self)`
- **목적**: 보루브카 알고리즘의 구현을 단순화하기 위해 모든 간선의 가중치를 서로 다르게 만듭니다.
- **동작**: 가중치가 같은 경우, 간선의 정점 인덱스 등을 고려하여 미세하게 가중치를 조정함으로써 유일성을 보장합니다.

### `boruvka_mst(graph)` (Static Method)
- **목적**: 주어진 그래프에 대해 보루브카 알고리즘을 수행하여 MST를 반환합니다.
- **알고리즘 동작**:
  1. **초기화**: `UnionFind` 자료구조를 초기화하고, 모든 정점을 각각의 컴포넌트로 둡니다.
  2. **반복 (While)**: 컴포넌트의 개수가 1보다 큰 동안 반복합니다.
     - **최소 간선 찾기**: 각 컴포넌트(Set)에 대해, 해당 컴포넌트와 외부를 연결하는 가장 가중치가 작은 간선(`cheap_edge`)을 찾습니다.
     - **병합 (Union)**: 찾은 최소 간선들을 확인하며, 두 컴포넌트가 아직 연결되지 않았다면 간선을 MST에 추가하고 두 컴포넌트를 합칩니다(`union`).
     - **컴포넌트 수 감소**: 병합이 일어날 때마다 전체 컴포넌트 수를 줄입니다.
  3. **반환**: 찾아낸 간선들로 구성된 새로운 `Graph` 객체(MST)를 반환합니다.

## 내부 클래스: `UnionFind`

서로소 집합(Disjoint Set) 자료구조를 구현한 클래스입니다.
- **`find(item)`**: 원소가 속한 집합의 대표(루트)를 찾습니다. 경로 압축(Path Compression)을 사용합니다.
- **`union(item1, item2)`**: 두 원소가 속한 집합을 합칩니다. 랭크(Rank)를 기반으로 트리의 높이를 최소화합니다.

## 사용법

`boruvka_mst` 메서드의 독스트링(Docstring)에 포함된 예제를 통해 동작을 확인할 수 있습니다.

```python
g = Graph()
# 정점과 간선으로 그래프 생성
g = Graph.build([0, 1, 2, 3], [[0, 1, 1], [0, 2, 1], [2, 3, 1]])
# 가중치 고유화 (선택 사항, 구현상 필요할 수 있음)
g.distinct_weight()
# MST 계산
bg = Graph.boruvka_mst(g)
print(bg)
```

## 참고 사항
- 이 구현에서는 `distinct_weight`를 사용하여 가중치가 동일한 간선 처리를 단순화했습니다.
- `UnionFind` 클래스는 알고리즘의 효율성을 위해 필수적입니다.