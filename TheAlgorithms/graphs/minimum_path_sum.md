# 최소 경로 합 (Minimum Path Sum)

이 문서는 `minimum_path_sum.py` 파일에 구현된 **최소 경로 합** 알고리즘에 대해 설명합니다.

## 개요

이 알고리즘은 $m \times n$ 크기의 숫자 그리드가 주어졌을 때, 좌측 상단(Top-Left)에서 우측 하단(Bottom-Right)으로 이동하는 경로 중 숫자의 합이 가장 작은 경로를 찾는 문제입니다. 이동은 오직 **오른쪽**이나 **아래쪽**으로만 가능합니다.

이 구현은 **동적 계획법(Dynamic Programming)**을 사용하여 그리드 자체를 갱신하는 방식(In-place)으로 메모리 사용을 최적화합니다.

## 주요 함수

### `min_path_sum(grid: list) -> int`

- **목적**: 그리드의 좌측 상단에서 우측 하단까지의 최소 경로 합을 계산하여 반환합니다.
- **매개변수**:
  - `grid`: 숫자로 이루어진 2차원 리스트.
- **반환값**: 최소 경로의 합 (정수).
- **알고리즘 동작**:
  1. **유효성 검사**: 그리드가 비어있거나 유효하지 않은 경우 `TypeError`를 발생시킵니다.
  2. **첫 번째 행 초기화**: 첫 번째 행의 각 셀은 왼쪽에서만 올 수 있으므로, 왼쪽 셀의 누적 합을 더해 갱신합니다.
  3. **나머지 행 처리**: 두 번째 행부터 마지막 행까지 순회하며 `fill_row` 함수를 호출하여 각 셀의 최소 합을 계산합니다.
  4. **결과 반환**: 그리드의 우측 하단(`grid[-1][-1]`) 값을 반환합니다.

### `fill_row(current_row: list, row_above: list) -> list`

- **목적**: 현재 행(`current_row`)의 각 셀에 도달하기 위한 최소 합을 계산합니다.
- **매개변수**:
  - `current_row`: 값을 갱신할 현재 행.
  - `row_above`: 바로 위쪽 행 (이미 최소 합으로 갱신된 상태).
- **동작 원리**:
  1. **첫 번째 열**: 현재 행의 첫 번째 셀(`current_row[0]`)은 위쪽에서만 올 수 있으므로, 바로 위 셀(`row_above[0]`)의 값을 더합니다.
  2. **나머지 열**: 나머지 셀들은 위쪽(`row_above[cell_n]`) 또는 왼쪽(`current_row[cell_n - 1]`) 중 더 작은 값을 선택하여 현재 셀의 값에 더합니다.
     - 점화식: `dp[i][j] += min(dp[i-1][j], dp[i][j-1])`

## 사용법

`if __name__ == "__main__":` 블록에서 `doctest`를 실행하여 코드를 검증합니다.

사용 예시:
```python
grid = [
    [1, 3, 1],
    [1, 5, 1],
    [4, 2, 1],
]
print(min_path_sum(grid))
# 출력: 7
# 경로: 1 -> 3 -> 1 -> 1 -> 1
```

## 특징

- **시간 복잡도**: $O(M \times N)$, 그리드의 모든 셀을 한 번씩 방문합니다.
- **공간 복잡도**: $O(1)$, 입력받은 `grid`를 직접 수정하여 추가적인 메모리 공간을 거의 사용하지 않습니다. (단, 입력 데이터가 보존되어야 하는 경우에는 복사본을 사용해야 합니다.)
