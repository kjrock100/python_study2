# 짝수 트리 (Even Tree)

이 문서는 `even_tree.py` 파일에 구현된 **짝수 트리 분할 알고리즘**에 대해 설명합니다.

## 개요

이 알고리즘은 $N$개의 노드를 가진 트리(루트는 1번)가 주어졌을 때, 트리의 간선을 제거하여 얻어지는 숲(Forest)의 모든 연결 요소(Connected Component)가 **짝수 개의 노드**를 가지도록 만들 수 있는 **최대 간선 제거 횟수**를 구하는 문제입니다.

## 문제 조건

- 트리의 노드 수 $N$은 짝수라고 가정합니다.
- 트리는 항상 짝수 개의 노드를 가진 컴포넌트들로 분해될 수 있는 형태입니다.

## 알고리즘 동작 원리 (DFS)

이 문제는 **깊이 우선 탐색(DFS)**을 사용하여 해결할 수 있습니다. 핵심 아이디어는 다음과 같습니다.

1. **서브트리 노드 수 계산**: 리프 노드(Leaf Node)부터 시작하여 위쪽(루트 방향)으로 올라가면서 각 노드를 루트로 하는 서브트리의 노드 개수를 셉니다.
2. **간선 제거 판단**: 만약 특정 노드 `u`를 루트로 하는 서브트리의 전체 노드 개수가 **짝수**라면, `u`와 그 부모를 연결하는 간선을 제거할 수 있습니다.
   - 서브트리의 노드 수가 짝수라면, 전체 트리 노드 수도 짝수이므로, 이 서브트리를 분리해도 남은 부분의 노드 수 역시 짝수가 유지됩니다.

## 주요 함수

### `dfs(start: int) -> int`

- **목적**: `start` 노드를 루트로 하는 서브트리의 노드 개수를 계산하고 반환합니다.
- **동작**:
  1. 현재 노드 `start`를 방문 처리합니다.
  2. `ret` 변수를 1로 초기화합니다 (자기 자신 포함).
  3. 인접한 노드(자식 노드)들에 대해 재귀적으로 `dfs`를 호출하고, 반환된 서브트리의 노드 수를 `ret`에 더합니다.
  4. 만약 현재 서브트리의 총 노드 수 `ret`가 **짝수**라면:
     - `cuts` 리스트에 현재 노드를 추가합니다. (이 노드 위쪽의 간선을 자를 수 있음을 의미)
  5. `ret`를 반환합니다.

### `even_tree()`

- **목적**: 알고리즘을 시작하는 래퍼(Wrapper) 함수입니다.
- **동작**: 루트 노드인 `1`번 노드부터 `dfs` 탐색을 시작합니다.

## 실행 결과 계산

`if __name__ == "__main__":` 블록에서 최종 결과를 출력할 때 `len(cuts) - 1`을 계산합니다.

- `cuts` 리스트에는 서브트리의 노드 수가 짝수인 모든 노드가 포함됩니다.
- 전체 트리의 노드 수($N$)도 짝수이므로, 루트 노드(1번)도 항상 `cuts`에 포함됩니다.
- 하지만 루트 노드는 부모가 없어서 제거할 간선이 존재하지 않으므로, 전체 개수에서 1을 빼줍니다.

## 사용법

코드 하단에 예제 그래프 데이터가 포함되어 있으며, 실행 시 최대 제거 가능한 간선의 수를 출력합니다.

```python
# 예제 그래프 간선
edges = [(2, 1), (3, 1), (4, 3), (5, 2), (6, 1), (7, 2), (8, 6), (9, 8), (10, 8)]
# ...
even_tree()
print(len(cuts) - 1)
# 출력 결과: 2
```

위 예제에서 제거되는 간선은 `(1, 3)`과 `(1, 6)`입니다.
