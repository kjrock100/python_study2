# `horn_schunck.py` 코드 설명

이 문서는 `horn_schunck.py` 파이썬 스크립트를 설명합니다. 이 스크립트는 연속된 두 이미지 프레임 간의 픽셀 움직임을 추정하는 **광학 흐름(Optical Flow)** 알고리즘 중 하나인 **혼-셩크 방법(Horn-Schunck method)**을 구현합니다.

## 목차
1.  혼-셩크 방법이란?
2.  함수 설명
    -   `warp(image, horizontal_flow, vertical_flow)`
    -   `horn_schunck(image0, image1, num_iter, alpha)`
3.  실행 방법
4.  코드 개선 제안

## 혼-셩크 방법이란?

혼-셩크 방법은 두 개의 연속된 이미지 프레임 사이에서 각 픽셀이 어떻게 이동했는지를 나타내는 속도 벡터(광학 흐름)를 계산하는 고전적인 알고리즘입니다. 이 방법은 두 가지 핵심 가정을 기반으로 합니다.

1.  **밝기 항상성 (Brightness Constancy)**: 한 프레임의 특정 픽셀은 다음 프레임으로 이동하더라도 그 밝기 값이 변하지 않습니다.
2.  **흐름의 부드러움 (Smoothness of Flow)**: 이웃한 픽셀들은 서로 유사한 방향과 속도로 움직이는 경향이 있습니다.

이 두 가정을 수학적 제약 조건으로 사용하여, 모든 픽셀에 대한 광학 흐름(수평 이동량 `u`와 수직 이동량 `v`)을 반복적으로 계산하여 최적의 해를 찾아갑니다.

## 함수 설명

### `warp(image: np.ndarray, horizontal_flow: np.ndarray, vertical_flow: np.ndarray) -> np.ndarray`

주어진 광학 흐름(수평 및 수직 이동량)을 사용하여 이미지를 "뒤틀어서(warp)" 새로운 이미지를 생성합니다.

-   **역할**: `image0`에 광학 흐름을 적용하여 `image1`과 유사한 이미지를 만들어내는 데 사용됩니다. 이는 현재 추정된 흐름이 얼마나 정확한지 평가하는 데 필요합니다.
-   **알고리즘**:
    1.  결과 이미지의 각 픽셀 `(x, y)`에 대해, 이 픽셀이 원본 이미지의 어느 위치 `(x - u, y - v)`에서 왔는지를 계산합니다.
    2.  계산된 원본 위치의 픽셀 값을 가져와 결과 이미지의 `(x, y)` 위치에 채워 넣습니다.
    3.  만약 원본 위치가 이미지 경계를 벗어나면, 해당 픽셀은 0으로 처리합니다.

### `horn_schunck(image0: np.ndarray, image1: np.ndarray, num_iter: SupportsIndex, alpha: float | None = None) -> tuple[np.ndarray, np.ndarray]`

두 개의 연속된 그레이스케일 이미지(`image0`, `image1`)를 입력받아 혼-셩크 알고리즘을 수행하고, 추정된 광학 흐름(수평, 수직)을 반환합니다.

-   **인자**:
    -   `image0`, `image1`: 연속된 두 프레임의 이미지 배열.
    -   `num_iter`: 흐름을 개선하기 위한 반복 횟수.
    -   `alpha`: 정규화 상수로, 흐름의 부드러움 제약 조건의 가중치를 조절합니다.

-   **알고리즘**:
    1.  **초기화**: 수평(`horizontal_flow`) 및 수직(`vertical_flow`) 흐름을 모두 0으로 초기화합니다.
    2.  **미분 계산용 커널 준비**: 이미지의 공간적(x, y) 및 시간적(t) 미분을 계산하기 위한 컨볼루션 커널과, 이웃 흐름의 평균을 계산하기 위한 라플라시안 커널을 준비합니다.
    3.  **반복적 개선**: `num_iter` 횟수만큼 다음 과정을 반복합니다.
        -   `warp` 함수를 사용하여 현재 흐름으로 `image0`을 변형한 `warped_image`를 생성합니다.
        -   `warped_image`와 `image1`을 사용하여 공간적, 시간적 미분(`derivative_x`, `derivative_y`, `derivative_t`)을 계산합니다.
        -   라플라시안 커널을 사용하여 현재 흐름의 국소 평균(`avg_horizontal_velocity`, `avg_vertical_velocity`)을 계산합니다.
        -   혼-셩크 논문에 제시된 업데이트 공식을 사용하여 수평 및 수직 흐름을 미세하게 조정합니다.
    4.  **결과 반환**: 최종적으로 계산된 수평 및 수직 흐름을 튜플 형태로 반환합니다.

## 실행 방법

스크립트를 직접 실행하면 내장된 `doctest`를 통해 각 함수의 예제 코드가 실행되고, 함수의 정확성이 자동으로 테스트됩니다.

```bash
python horn_schunck.py
```

별도의 출력이 없다면 모든 테스트가 성공적으로 통과한 것입니다.

## 코드 개선 제안

1.  **`warp` 함수의 효율성**: 현재 `warp` 함수는 `numpy`의 고급 인덱싱을 사용하여 효율적으로 구현되어 있습니다. 하지만 `scipy.ndimage.map_coordinates`와 같은 최적화된 라이브러리 함수를 사용하면 보간(interpolation) 기능을 포함하여 더 부드럽고 정확한 워핑 결과를 얻을 수 있습니다.

2.  **시각화 기능 추가**: 계산된 광학 흐름은 벡터 필드이므로, 이를 시각화하는 기능을 추가하면 알고리즘의 동작을 직관적으로 이해하는 데 큰 도움이 됩니다. `matplotlib.pyplot.quiver`를 사용하여 각 픽셀의 이동 방향과 크기를 화살표로 표시하거나, 흐름의 방향을 색상으로, 크기를 밝기로 표현하는 HSV 색상 맵을 사용할 수 있습니다.

3.  **이미지 피라미드 적용**: 혼-셩크 방법은 큰 움직임에 대해서는 정확도가 떨어지는 경향이 있습니다. 이를 개선하기 위해 **이미지 피라미드(Image Pyramid)** 기법을 적용할 수 있습니다. 저해상도 이미지에서 먼저 큰 움직임을 추정하고, 그 결과를 바탕으로 점차 고해상도 이미지에서 세밀한 움직임을 보정해 나가는 방식입니다.

4.  **사용자 인터페이스**: `if __name__ == "__main__"` 블록에 `argparse` 모듈을 사용하여 사용자가 직접 두 이미지 파일 경로, 반복 횟수, `alpha` 값 등을 커맨드 라인 인자로 지정할 수 있도록 하면 스크립트의 활용도가 높아집니다.