# 탐욕적 배낭 문제 (Greedy Knapsack Problem)

이 문서는 `greedy_knapsack.py` 파일에 구현된 **분할 가능한 배낭 문제(Fractional Knapsack Problem)** 해결 알고리즘에 대해 설명합니다.

## 개요

배낭 문제(Knapsack Problem)는 한정된 무게 용량을 가진 배낭에 가치가 다른 여러 물건을 넣을 때, 가치의 합이 최대가 되도록 물건을 고르는 문제입니다.

이 코드에서 다루는 **분할 가능한 배낭 문제**는 물건을 쪼개서 넣을 수 있다고 가정합니다(예: 곡물, 가루 등). 이 경우 **탐욕적 알고리즘(Greedy Algorithm)**을 사용하여 항상 최적해를 구할 수 있습니다. 핵심 아이디어는 **무게 대비 가치(Value per Unit Weight)**가 가장 높은 물건부터 우선적으로 배낭에 담는 것입니다.

## 주요 함수: `calc_profit`

### `calc_profit(profit: list, weight: list, max_weight: int) -> int`

- **목적**: 주어진 물건들과 배낭 용량에 대해 얻을 수 있는 최대 이익을 계산합니다.
- **매개변수**:
  - `profit`: 각 물건의 이익을 담은 리스트.
  - `weight`: 각 물건의 무게를 담은 리스트.
  - `max_weight`: 배낭의 최대 수용 무게.
- **반환값**: 최대 이익 (계산 과정에서 나눗셈이 포함되므로 실수형이 반환될 수 있습니다).

### 알고리즘 동작 원리

1. **유효성 검사**:
   - `profit`과 `weight` 리스트의 길이가 같은지 확인합니다.
   - `max_weight`가 0보다 큰지 확인합니다.
   - 이익과 무게가 음수가 아닌지 확인합니다.

2. **비율 계산**:
   - 각 물건의 단위 무게당 이익(`profit / weight`)을 계산하여 `profit_by_weight` 리스트를 만듭니다.

3. **정렬**:
   - `profit_by_weight`를 오름차순으로 정렬합니다. (코드에서는 뒤에서부터 접근하여 큰 값부터 처리합니다.)

4. **탐욕적 선택 루프**:
   - 단위 무게당 이익이 가장 높은 물건부터 순서대로 확인합니다.
   - **전체 포함 가능**: 현재 물건을 배낭에 통째로 넣을 수 있다면(`max_weight - limit >= weight[index]`), 물건을 다 넣고 무게와 이익을 갱신합니다.
   - **부분 포함**: 물건을 통째로 넣을 수 없다면, 배낭의 남은 용량만큼만 잘라서 넣습니다. 이익도 해당 비율만큼 추가하고 반복을 종료합니다(배낭이 꽉 찼으므로).

## 사용법

`if __name__ == "__main__":` 블록을 통해 스크립트를 직접 실행할 수 있습니다. 사용자로부터 이익, 무게, 최대 무게를 입력받아 결과를 출력합니다.

```python
# 실행 예시
# Input profits separated by spaces: 10 5 15 7 6 18 3
# Input weights separated by spaces: 2 3 5 7 1 4 1
# Max weight allowed: 15
```

## 주의 사항
- 이 알고리즘은 물건을 쪼갤 수 없는 **0/1 배낭 문제(0/1 Knapsack Problem)**에는 적용할 수 없습니다. 0/1 배낭 문제는 동적 계획법(Dynamic Programming) 등을 사용해야 합니다.
- 코드 내에서 `profit_by_weight`의 인덱스를 찾을 때 중복된 값이 있을 경우 항상 첫 번째 인덱스를 반환하므로, 처리된 항목을 `-1`로 변경하여 중복 처리를 방지하고 있습니다.
