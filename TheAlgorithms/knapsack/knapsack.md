# 0-1 배낭 문제 (0-1 Knapsack Problem)

이 문서는 `knapsack.py` 파일에 구현된 **0-1 배낭 문제** 해결 알고리즘에 대해 설명합니다.

## 개요

0-1 배낭 문제는 배낭의 용량(무게 제한)이 주어졌을 때, 무게와 가치가 있는 여러 물건 중 배낭에 넣을 물건들을 선택하여 가치의 합을 최대화하는 문제입니다. "0-1"이라는 이름은 물건을 쪼개서 넣을 수 없고, 통째로 넣거나(1) 넣지 않거나(0) 둘 중 하나만 선택할 수 있다는 의미입니다.

이 코드는 **재귀(Recursion)**를 사용한 가장 단순한 형태의 구현입니다.

## 주요 함수: `knapsack`

### `knapsack(capacity: int, weights: list[int], values: list[int], counter: int) -> int`

- **목적**: 주어진 용량 내에서 얻을 수 있는 최대 가치를 계산합니다.
- **매개변수**:
  - `capacity`: 배낭이 버틸 수 있는 최대 무게.
  - `weights`: 각 물건의 무게 리스트.
  - `values`: 각 물건의 가치 리스트.
  - `counter`: 고려할 남은 물건의 개수 (리스트의 인덱스 역할).
- **반환값**: 최대 가치 (정수).

### 알고리즘 동작 원리

1. **기저 사례 (Base Case)**:
   - 남은 물건이 없거나(`counter == 0`), 배낭의 용량이 0이면(`capacity == 0`), 더 이상 가치를 추가할 수 없으므로 `0`을 반환합니다.

2. **재귀 단계 (Recursive Step)**:
   - 현재 고려 중인 물건(`counter - 1` 인덱스)의 무게가 남은 용량(`capacity`)보다 크다면:
     - 이 물건은 넣을 수 없으므로, 이 물건을 제외하고 나머지 물건들로 함수를 재귀 호출합니다.
   - 현재 물건을 넣을 수 있다면, 다음 두 가지 경우 중 더 큰 값을 선택합니다 (`max` 함수 사용):
     1. **물건을 넣는 경우**: 현재 물건의 가치를 더하고, 용량을 줄인 상태로 나머지 물건들에 대해 재귀 호출합니다.
     2. **물건을 넣지 않는 경우**: 용량을 그대로 두고 나머지 물건들에 대해 재귀 호출합니다.

## 사용법

`if __name__ == "__main__":` 블록의 `doctest` 예제를 통해 동작을 확인할 수 있습니다.

```python
cap = 50
val = [60, 100, 120]
w = [10, 20, 30]
c = len(val)

print(knapsack(cap, w, val, c))
# 결과: 220
# 설명: 무게 20(가치 100)과 무게 30(가치 120)인 물건을 선택하면 총 무게 50, 총 가치 220이 됩니다.
```

## 주의 사항
- 이 구현은 **메모이제이션(Memoization)**이나 **동적 계획법(Dynamic Programming)**을 사용하지 않는 순수 재귀 방식입니다.
- 따라서 시간 복잡도가 $O(2^n)$으로, 물건의 개수($n$)가 많아지면 계산 시간이 기하급수적으로 증가하여 비효율적입니다.
