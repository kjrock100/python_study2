# `nagel_schrekenberg.py` 코드 설명

이 문서는 `nagel_schrekenberg.py` 파이썬 스크립트를 설명합니다. 이 스크립트는 단일 차선의 순환 도로에서의 교통 흐름을 시뮬레이션하는 세포 자동자(Cellular Automaton) 모델인 **나겔-슈레켄베르크(Nagel-Schreckenberg) 모델**을 구현합니다.

## 목차
1.  나겔-슈레켄베르크 모델이란?
2.  알고리즘 규칙
3.  함수 설명
    -   `construct_highway()`
    -   `get_distance()`
    -   `update()`
    -   `simulate()`
4.  실행 방법
5.  코드 개선 제안

## 나겔-슈레켄베르크 모델이란?

이 모델은 간단한 규칙들을 통해 실제 교통에서 관찰되는 정체 현상(traffic jam)과 같은 복잡한 동작을 재현할 수 있는 물리학 기반의 교통 흐름 모델입니다. 도로는 여러 개의 셀(cell)로 나뉘며, 각 셀에는 최대 한 대의 자동차만 존재할 수 있습니다. 자동차는 0부터 최대 속도까지의 정수 속도를 가집니다.

## 알고리즘 규칙

시뮬레이션의 각 단계(time step)에서 모든 자동차에 대해 다음 네 가지 규칙이 순서대로 적용됩니다.

1.  **가속 (Acceleration)**: 운전자는 속도를 높이려는 경향이 있습니다. 현재 속도가 최대 속도보다 낮으면 속도를 1만큼 증가시킵니다.
2.  **감속 (Slowing down)**: 충돌을 피하기 위해 앞차와의 거리를 확인합니다. 앞차까지의 거리가 현재 속도보다 짧으면, 거리에 맞춰 속도를 줄입니다.
3.  **무작위 감속 (Randomization)**: 운전자의 비합리적인 행동(예: 갑작스러운 감속)을 모방합니다. 정해진 확률(`p`)에 따라 속도를 1만큼 줄일 수 있습니다. (단, 속도는 0보다 낮아지지 않습니다.)
4.  **이동 (Car movement)**: 최종적으로 결정된 속도만큼 자동차를 앞으로 이동시킵니다.

## 함수 설명

### `construct_highway(number_of_cells, frequency, initial_speed, ...)`

시뮬레이션을 위한 초기 도로 상태를 생성합니다.

-   **역할**: 지정된 `frequency`(간격)와 `initial_speed`(초기 속도)에 따라 도로에 자동차를 배치합니다.
-   **반환값**: `list[list[int]]` 타입. 도로의 상태를 담은 리스트를 포함하는 리스트를 반환합니다. (예: `[[0, -1, -1, 0, -1, -1]]`)
    -   `-1`은 비어있는 셀을 의미합니다.
    -   `0` 이상의 정수는 해당 셀에 있는 자동차의 속도를 의미합니다.

### `get_distance(highway_now, car_index)`

특정 자동차(`car_index`)와 그 앞에 있는 다음 자동차 사이의 빈 공간(거리)을 계산합니다.

-   **알고리즘**:
    1.  현재 자동차의 위치부터 도로 끝까지 순회하며 다른 자동차를 찾습니다.
    2.  다른 자동차를 찾으면 그 사이의 빈 셀 개수를 반환합니다.
    3.  도로 끝까지 자동차를 찾지 못하면, 도로가 순환 구조이므로 재귀 호출을 통해 도로의 처음부터 다시 탐색을 시작합니다.

### `update(highway_now, probability, max_speed)`

현재 도로 상태(`highway_now`)를 기반으로 모든 자동차의 **다음 속도**를 계산합니다.

-   **역할**: 위에서 설명한 알고리즘 규칙 1, 2, 3 (가속, 감속, 무작위 감속)을 적용하여 각 자동차의 새로운 속도를 결정합니다.
-   **주의**: 이 함수는 자동차를 실제로 이동시키지 않고, 이동하기 직전의 속도만 계산하여 반환합니다.

### `simulate(highway, number_of_update, probability, max_speed)`

주어진 초기 도로 상태(`highway`)에서 지정된 횟수(`number_of_update`)만큼 시뮬레이션을 실행합니다.

-   **알고리즘**:
    1.  `number_of_update` 횟수만큼 루프를 반복합니다.
    2.  각 반복에서 `update()` 함수를 호출하여 모든 자동차의 새로운 속도를 계산합니다.
    3.  계산된 속도를 바탕으로 각 자동차를 새로운 위치로 이동시킵니다. (알고리즘 규칙 4)
        -   `새로운 위치 = (현재 위치 + 속도) % 도로 길이` 공식을 사용하여 순환 도로를 구현합니다.
    4.  새로운 도로 상태를 결과 리스트에 추가합니다.
    5.  모든 시뮬레이션이 끝나면 전체 시간 경과에 따른 도로 상태의 변화를 담은 리스트를 반환합니다.

## 실행 방법

스크립트를 직접 실행하면 내장된 `doctest`를 통해 각 함수의 예제 코드가 실행되고 테스트됩니다.

```bash
python nagel_schrekenberg.py
```

## 코드 개선 제안

1.  **`get_distance` 함수 효율성 개선**: 현재 `get_distance` 함수는 재귀와 슬라이싱을 사용하여 비효율적일 수 있습니다. `while` 루프와 모듈러 연산(`%`)을 사용하면 더 빠르고 간결하게 거리를 계산할 수 있습니다.

    ```python
    # 개선 제안 예시
    def get_distance(highway_now: list, car_index: int) -> int:
        distance = 0
        size = len(highway_now)
        next_pos = (car_index + 1) % size
        while highway_now[next_pos] == -1:
            distance += 1
            next_pos = (next_pos + 1) % size
        return distance
    ```

2.  **데이터 구조 변경**: `simulate` 함수는 매번 도로 상태를 리스트의 리스트(`highway`)에 추가합니다. 이는 시뮬레이션 횟수가 많아질수록 메모리 사용량을 크게 증가시킬 수 있습니다. 시각화가 목적이라면, 매 단계의 상태를 저장하는 대신 즉시 렌더링하거나, `numpy` 배열을 사용하여 메모리 효율을 높이는 것이 좋습니다.

3.  **`update`와 `simulate` 로직 통합**: 현재 `update`는 속도만 계산하고, `simulate`에서 실제 이동을 처리합니다. 이 두 단계는 논리적으로 강하게 연결되어 있으므로, 하나의 함수(예: `step`)로 통합하면 코드의 흐름을 이해하기 더 쉬워집니다. `simulate` 함수는 이 `step` 함수를 반복 호출하는 역할만 맡게 됩니다.

4.  **변수명 명확화**: `get_distance` 함수의 `cell` 변수는 실제로는 인덱스를 의미하므로 `i`나 `offset`과 같은 이름이 더 적절합니다. 명확한 변수명은 코드의 가독성을 높입니다.

5.  **시각화 기능 추가**: 이 모델은 시각화를 통해 그 동작을 확인할 때 가장 흥미롭습니다. `matplotlib`이나 `pygame` 같은 라이브러리를 사용하여 시간 경과에 따른 자동차의 움직임을 시각화하는 기능을 추가하면 스크립트의 활용도를 크게 높일 수 있습니다.
