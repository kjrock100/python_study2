# `conways_game_of_life.py` 코드 설명

이 문서는 `conways_game_of_life.py` 파이썬 스크립트를 설명합니다. 이 스크립트는 존 호튼 콘웨이(John Horton Conway)가 고안한 **생명 게임(Game of Life)** 시뮬레이션을 구현합니다.

## 목차
1.  생명 게임이란?
2.  주요 데이터
3.  함수 설명
    -   `new_generation(cells)`
    -   `generate_images(cells, frames)`
4.  실행 방법
5.  코드 개선 제안

## 생명 게임이란?

생명 게임은 2차원 격자 위에서 벌어지는 세포 자동자(Cellular Automaton) 시뮬레이션입니다. 각 셀(세포)은 '삶'(1) 또는 '죽음'(0)의 상태를 가지며, 다음 세대의 상태는 주변 8개 셀의 상태에 따라 간단한 규칙으로 결정됩니다.

-   **규칙 1 (생존)**: 살아있는 셀(1) 주변에 살아있는 이웃이 2개 또는 3개 있으면 다음 세대에도 살아남습니다.
-   **규칙 2 (탄생)**: 죽어있는 셀(0) 주변에 살아있는 이웃이 정확히 3개 있으면 다음 세대에 살아납니다.
-   **규칙 3 (죽음)**: 그 외의 모든 경우(과밀 또는 외로움), 셀은 다음 세대에 죽습니다.

이 간단한 규칙만으로 복잡하고 예측 불가능한 패턴이 만들어집니다.

## 주요 데이터

스크립트에는 두 가지 초기 패턴 예시가 정의되어 있습니다.

-   `GLIDER`: 대각선으로 이동하는 기본적인 패턴입니다.
-   `BLINKER`: 세 개의 셀이 수평과 수직 상태를 반복하는 패턴입니다.

이 패턴들은 2차원 리스트로 표현되며, `1`은 살아있는 셀, `0`은 죽은 셀을 의미합니다.

## 함수 설명

### `new_generation(cells)`

현재 세대의 셀 상태(`cells`)를 입력받아 생명 게임의 규칙에 따라 다음 세대의 상태를 계산하여 반환합니다.

-   **알고리즘**:
    1.  모든 셀을 순회하면서 각 셀의 주변 8개 이웃 중 살아있는 셀의 개수를 셉니다.
    2.  격자의 경계에 있는 셀들은 존재하는 이웃만 계산합니다.
    3.  위에서 설명한 생명 게임의 세 가지 규칙을 적용하여 다음 세대에서 해당 셀이 살아있을지(1) 죽어있을지(0) 결정합니다.
    4.  모든 셀에 대한 계산이 끝나면 새로운 세대의 상태를 담은 2차원 리스트를 반환합니다.

### `generate_images(cells, frames)`

초기 셀 상태(`cells`)와 생성할 프레임 수(`frames`)를 입력받아, 여러 세대에 걸친 시뮬레이션 결과를 이미지 리스트로 생성합니다.

-   **역할**: 시뮬레이션 과정을 시각화하여 GIF 애니메이션으로 저장할 수 있도록 준비합니다.
-   **알고리즘**:
    1.  `frames` 수만큼 반복합니다.
    2.  각 반복마다 현재 `cells` 상태를 `Pillow` 라이브러리를 이용해 흑백 이미지로 변환합니다. (살아있는 셀: 검은색, 죽은 셀: 흰색)
    3.  생성된 이미지를 리스트에 추가합니다.
    4.  `new_generation()` 함수를 호출하여 `cells` 상태를 다음 세대로 업데이트합니다.
    5.  모든 프레임이 생성되면 이미지 리스트를 반환합니다.

## 실행 방법

스크립트를 직접 실행하면 `GLIDER` 패턴을 초기 상태로 하여 16 프레임의 시뮬레이션을 진행하고, 그 결과를 `out.gif`라는 이름의 애니메이션 GIF 파일로 저장합니다.

```bash
python conways_game_of_life.py
```

실행을 위해서는 `Pillow` 라이브러리가 설치되어 있어야 합니다.

```bash
pip install Pillow
```

## 코드 개선 제안

1.  **이웃 계산 로직 단순화**: `new_generation` 함수에서 8개의 이웃을 확인하는 8개의 `if` 문은 코드를 길고 복잡하게 만듭니다. 이 부분은 중첩 `for` 루프를 사용하여 더 간결하게 개선할 수 있습니다.

    ```python
    # 개선 제안 예시
    def count_neighbours(cells, r, c):
        count = 0
        rows, cols = len(cells), len(cells[0])
        for i in range(r - 1, r + 2):
            for j in range(c - 1, c + 2):
                # 자기 자신은 제외하고, 격자 범위 내에 있는지 확인
                if (i, j) != (r, c) and 0 <= i < rows and 0 <= j < cols:
                    count += cells[i][j]
        return count
    ```

2.  **가독성 향상**: 규칙을 적용하는 `if` 조건문이 다소 복잡합니다. 각 규칙을 명확히 설명하는 주석을 추가하거나, 조건을 더 직관적인 변수로 나누면 가독성을 높일 수 있습니다.

    ```python
    # 개선 제안 예시
    is_alive = cells[i][j] == 1
    
    # 규칙 1: 생존
    if is_alive and neighbour_count in [2, 3]:
        next_generation_row.append(1)
    # 규칙 2: 탄생
    elif not is_alive and neighbour_count == 3:
        next_generation_row.append(1)
    # 규칙 3: 죽음
    else:
        next_generation_row.append(0)
    ```

3.  **설정 분리**: 초기 패턴(`GLIDER`), 프레임 수(`16`), 출력 파일명(`out.gif`)이 코드에 하드코딩되어 있습니다. 이 값들을 `main` 함수의 인자로 받거나, 커맨드 라인 인자로 처리하도록 수정하면 스크립트의 재사용성이 크게 향상됩니다.

4.  **경계 처리 방식(Boundary Conditions)**: 현재 코드는 유한한 격자를 가정합니다. 생명 게임에서는 종종 "순환하는 경계(toroidal array)"를 사용하는데, 이는 격자의 왼쪽 끝이 오른쪽 끝과, 위쪽 끝이 아래쪽 끝과 연결된 것처럼 처리하는 방식입니다. 이 방식을 구현하면 더 흥미로운 패턴을 관찰할 수 있습니다.
