# `game_of_life.py` 코드 설명

이 문서는 `game_of_life.py` 파이썬 스크립트를 설명합니다. 이 스크립트는 `numpy`와 `matplotlib` 라이브러리를 사용하여 **콘웨이의 생명 게임(Conway's Game of Life)**을 실시간으로 시뮬레이션하고 시각화합니다.

## 목차
1.  생명 게임 규칙
2.  함수 설명
    -   `create_canvas(size)`
    -   `seed(canvas)`
    -   `__judge_point(pt, neighbours)`
    -   `run(canvas)`
3.  실행 방법
4.  코드 개선 제안

## 생명 게임 규칙

이 스크립트는 생명 게임의 네 가지 기본 규칙을 따릅니다.

1.  **저밀도**: 살아있는 셀(세포) 주변에 살아있는 이웃이 1개 이하이면, 외로워서 죽습니다.
2.  **생존**: 살아있는 셀 주변에 살아있는 이웃이 2개 또는 3개이면, 다음 세대에도 살아남습니다.
3.  **과밀**: 살아있는 셀 주변에 살아있는 이웃이 4개 이상이면, 인구 과밀로 죽습니다.
4.  **탄생**: 죽어있는 셀 주변에 살아있는 이웃이 정확히 3개이면, 새로운 셀이 태어납니다.

## 함수 설명

### `create_canvas(size)`

지정된 `size`에 맞춰 정사각형 모양의 2차원 격자(캔버스)를 생성합니다.

-   **역할**: 시뮬레이션이 진행될 공간을 초기화합니다.
-   **구조**: 모든 셀이 `False`(죽음) 상태인 2차원 리스트를 반환합니다.

### `seed(canvas)`

주어진 캔버스를 무작위 상태의 셀들로 채웁니다.

-   **역할**: 시뮬레이션의 초기 상태를 무작위로 설정합니다.
-   **동작**: 캔버스의 각 셀을 순회하며 `random.getrandbits(1)`을 이용해 `True`(삶) 또는 `False`(죽음) 상태를 임의로 할당합니다. 이 함수는 캔버스를 직접 수정합니다(in-place).

### `__judge_point(pt, neighbours)`

단일 셀의 다음 세대 상태를 결정합니다.

-   **역할**: 생명 게임의 핵심 규칙을 적용하는 내부 헬퍼 함수입니다.
-   **알고리즘**:
    1.  입력받은 3x3 크기의 이웃(`neighbours`) 내에서 살아있는 셀과 죽은 셀의 개수를 셉니다.
    2.  자기 자신(`pt`)은 이웃 수 계산에서 제외합니다.
    3.  위에서 설명한 생명 게임 규칙에 따라 현재 셀(`pt`)의 다음 상태(`True` 또는 `False`)를 결정하여 반환합니다.

### `run(canvas)`

전체 캔버스에 대해 생명 게임 규칙을 한 세대 진행시키고, 다음 세대의 캔버스 상태를 반환합니다.

-   **알고리즘**:
    1.  입력받은 파이썬 리스트 `canvas`를 `numpy` 배열로 변환하여 계산 효율을 높입니다.
    2.  모든 셀을 순회하면서 각 셀의 3x3 이웃 영역을 `numpy`의 슬라이싱 기능(`current_canvas[r-1:r+2, c-1:c+2]`)을 이용해 추출합니다.
    3.  추출된 이웃 영역과 현재 셀의 상태를 `__judge_point` 함수에 전달하여 다음 세대의 상태를 계산합니다.
    4.  계산된 결과는 새로운 `next_gen_canvas`에 저장됩니다.
    5.  모든 셀의 계산이 끝나면, `numpy` 배열인 `next_gen_canvas`를 다시 파이썬 리스트로 변환하여 반환합니다.

> **참고**: 이 함수의 `numpy` 슬라이싱 방식은 경계에서 음수 인덱스를 사용하게 되어, 격자의 양 끝이 서로 연결되는 **순환 경계(Toroidal Boundary)** 효과를 자연스럽게 구현합니다.

## 실행 방법

이 스크립트는 커맨드 라인에서 실행하며, 캔버스의 크기를 인자로 받습니다.

1.  **필요한 라이브러리 설치**:
    ```bash
    pip install numpy matplotlib
    ```

2.  **스크립트 실행**:
    ```bash
    python game_of_life.py 100
    ```
    위 명령어는 100x100 크기의 캔버스에서 시뮬레이션을 시작합니다. `matplotlib` 창이 나타나 실시간으로 변화하는 패턴을 보여줍니다. 시뮬레이션을 중단하려면 `Ctrl+C`를 누릅니다.

## 코드 개선 제안

1.  **효율성 증대**: `__judge_point` 함수는 3x3 이웃을 매번 순회합니다. `numpy.sum()`을 사용하면 이웃의 수를 더 빠르고 간결하게 계산할 수 있습니다.

    ```python
    # __judge_point 개선 제안 예시
    def __judge_point(pt: bool, neighbours: np.ndarray) -> bool:
        # numpy 배열의 sum()을 사용하여 살아있는 이웃 수를 계산
        # pt가 True이면 자기 자신(1)을 빼줌
        alive_neighbours = neighbours.sum() - pt

        if pt:  # 현재 셀이 살아있을 때
            # 규칙 1, 3: 2 미만 또는 3 초과면 죽음
            return alive_neighbours in [2, 3]
        else:  # 현재 셀이 죽어있을 때
            # 규칙 4: 정확히 3이면 살아남
            return alive_neighbours == 3
    ```

2.  **NumPy 최적화**: `run` 함수 내의 이중 `for` 루프는 `numpy`의 장점을 완전히 활용하지 못합니다. `scipy.signal.convolve2d`나 `numpy.roll`을 사용한 벡터화(vectorization) 기법을 적용하면 전체 캔버스의 다음 상태를 루프 없이 한 번에 계산할 수 있어 성능이 크게 향상됩니다.

3.  **전역 변수 사용 지양**: `choice` 리스트가 전역 변수로 정의되어 있습니다. `seed` 함수 내에서 지역적으로 생성하고 사용하는 것이 코드의 명확성과 재사용성을 높이는 데 도움이 됩니다.

4.  **명확한 에러 처리**: `if len(sys.argv) != 2:` 부분에서 `Exception(usage_doc)`을 발생시키는 대신, `print(usage_doc)`를 호출하고 `sys.exit(1)`로 종료하는 것이 더 표준적인 커맨드 라인 애플리케이션의 동작 방식입니다.
