# `one_dimensional.py` 코드 설명

이 문서는 `one_dimensional.py` 파이썬 스크립트를 설명합니다. 이 스크립트는 **1차원 세포 자동자(1D Cellular Automaton)**의 진화 과정을 시뮬레이션하고, 그 결과를 이미지로 생성합니다. 특히, 스티븐 울프럼(Stephen Wolfram)이 제안한 기본 세포 자동자 규칙을 따릅니다.

## 목차
1.  1차원 세포 자동자란?
2.  함수 설명
    -   `format_ruleset(ruleset)`
    -   `new_generation(cells, rule, time)`
    -   `generate_image(cells)`
3.  실행 방법
4.  코드 개선 제안

## 1차원 세포 자동자란?

1차원 세포 자동자는 일렬로 배열된 셀(세포)들로 구성됩니다. 각 셀은 켜짐(1) 또는 꺼짐(0) 상태를 가집니다. 다음 세대의 각 셀 상태는 현재 세대에서 **자신과 바로 왼쪽, 오른쪽 이웃 셀**의 상태에 의해 결정됩니다.

이 세 셀(왼쪽, 자신, 오른쪽)이 만들 수 있는 상태는 `111`부터 `000`까지 총 8가지입니다. **규칙(Ruleset)**은 이 8가지 패턴 각각에 대해 다음 세대의 셀이 어떤 상태(1 또는 0)가 될지를 정의한 8비트 이진수입니다. 예를 들어, 유명한 "규칙 30"은 이진수로 `00011110`입니다.

## 함수 설명

### `format_ruleset(ruleset)`

사용자가 입력한 규칙 번호(정수)를 시뮬레이션에 사용할 수 있는 8비트 이진수 리스트로 변환합니다.

-   **역할**: 정수 형태의 규칙 번호를 8개의 `0` 또는 `1`로 이루어진 리스트로 포맷합니다. 예를 들어, 30은 `[0, 0, 0, 1, 1, 1, 1, 0]`으로 변환됩니다.
-   **알고리즘**: 입력된 숫자를 8자리 이진수 문자열로 변환한 후, 각 문자를 정수로 바꿔 리스트에 담습니다.

```python
>>> format_ruleset(30)  # 30의 이진수는 11110
[0, 0, 0, 1, 1, 1, 1, 0]
>>> format_ruleset(90)  # 90의 이진수는 1011010
[0, 1, 0, 1, 1, 0, 1, 0]
```

### `new_generation(cells, rule, time)`

현재 세대의 셀 상태와 규칙을 바탕으로 다음 세대의 셀 상태를 계산합니다.

-   **알고리즘**:
    1.  현재 세대(`cells[time]`)의 모든 셀을 순회합니다.
    2.  각 셀에 대해 왼쪽 이웃, 현재 셀, 오른쪽 이웃의 상태를 가져옵니다. (경계를 벗어나는 이웃은 `0`으로 처리)
    3.  세 이웃의 상태를 이진수 문자열(예: `'101'`)로 결합하고, 이를 10진수 정수(예: 5)로 변환합니다.
    4.  `format_ruleset`으로 생성된 `rule` 리스트에서 해당 10진수 값을 인덱스로 사용하여 다음 세대의 셀 상태를 결정합니다. (규칙에 따라 `rule[7 - index]`를 사용)
    5.  계산된 모든 셀의 상태를 리스트로 묶어 다음 세대로 반환합니다.

### `generate_image(cells)`

시뮬레이션된 모든 세대의 기록(`cells`)을 흑백 이미지로 변환합니다.

-   **역할**: `Pillow` 라이브러리를 사용하여 세포 자동자의 진화 과정을 시각화합니다.
-   **동작**:
    1.  세대 수(높이)와 셀 개수(너비)에 맞는 빈 이미지를 생성합니다.
    2.  `cells` 2차원 리스트를 순회하며 각 셀의 상태에 따라 픽셀을 칠합니다.
        -   `1` (켜짐): 검은색
        -   `0` (꺼짐): 흰색
    3.  완성된 이미지를 반환합니다.

## 실행 방법

스크립트를 직접 실행하면 사용자에게 규칙 번호를 입력받아 16세대에 걸친 시뮬레이션을 수행하고, 그 결과를 이미지 창으로 보여줍니다.

1.  **필요한 라이브러리 설치**:
    ```bash
    pip install Pillow
    ```

2.  **스크립트 실행**:
    ```bash
    python one_dimensional.py
    ```

3.  **규칙 번호 입력**:
    터미널에 `Rule:` 프롬프트가 나타나면 원하는 규칙 번호(예: `30`, `90`, `110`)를 입력하고 엔터를 누릅니다.

## 코드 개선 제안

1.  **입력 처리 개선**: 현재 `main` 블록의 입력 처리 로직(`rule_num = bin(int(input(...)))[2:]`)은 다소 복잡하고, 사용자가 숫자가 아닌 값을 입력했을 때 오류가 발생합니다. `try-except` 블록을 사용하여 더 안정적으로 입력을 처리할 수 있습니다.

    ```python
    # 개선 제안 예시
    if __name__ == "__main__":
        try:
            rule_input = input("Rule:\n").strip()
            rule_num = int(rule_input)
            if not (0 <= rule_num <= 255):
                raise ValueError("Rule number must be between 0 and 255.")
        except ValueError as e:
            print(f"Invalid input: {e}")
        else:
            rule = format_ruleset(rule_num)
            # ... (이후 시뮬레이션 로직)
    ```

2.  **전역 변수 사용 지양**: `CELLS` 리스트가 전역 변수로 정의되고 `main` 블록에서 직접 수정됩니다. 이 변수를 `main` 함수 내의 지역 변수로 만들고, 시뮬레이션 함수에 인자로 전달하는 것이 코드의 명확성과 재사용성을 높입니다.

3.  **함수 분리 및 역할 명확화**: `main` 블록의 시뮬레이션 루프를 별도의 함수(예: `run_simulation(initial_cells, rule, generations)`)로 분리하면 좋습니다. 이렇게 하면 시뮬레이션 로직을 다른 곳에서 쉽게 재사용할 수 있습니다.

4.  **`format_ruleset` 함수 단순화**: 이진수 변환과 패딩을 `bin()`과 문자열 포매팅을 조합하여 더 간결하게 작성할 수 있습니다.

    ```python
    # 개선 제안 예시
    def format_ruleset(ruleset: int) -> list[int]:
        # bin(ruleset) -> '0b11110'
        # [2:] -> '11110'
        # .zfill(8) -> '00011110'
        binary_string = bin(ruleset)[2:].zfill(8)
        return [int(bit) for bit in binary_string]
    ```
