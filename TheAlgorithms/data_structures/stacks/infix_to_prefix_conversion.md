# `infix_to_prefix_conversion.py` 코드 설명

이 문서는 `infix_to_prefix_conversion.py` 스크립트에 구현된, 중위 표기법(Infix Notation) 수식을 전위 표기법(Prefix Notation)으로 변환하는 알고리즘에 대해 설명합니다.

## 1. 중위, 후위, 전위 표기법

-   **중위 표기법 (Infix)**: 연산자가 피연산자 사이에 위치합니다. (예: `a + b`)
-   **후위 표기법 (Postfix)**: 연산자가 피연산자 뒤에 위치합니다. (예: `a b +`)
-   **전위 표기법 (Prefix)**: 연산자가 피연산자 앞에 위치합니다. (예: `+ a b`)

이 스크립트는 중위 표기법을 전위 표기법으로 변환하는 기능을 제공합니다.

## 2. 핵심 알고리즘: 후위 표기법 변환 응용

이 코드는 중위 표기법을 전위 표기법으로 직접 변환하는 대신, 후위 표기법 변환 알고리즘을 응용하는 독창적인 방법을 사용합니다.

**알고리즘 단계:**
1.  **수식 뒤집기**: 입력받은 중위 표기법 수식의 순서를 완전히 뒤집습니다.
2.  **괄호 뒤집기**: 뒤집힌 수식에서 여는 괄호 `(`는 닫는 괄호 `)`로, 닫는 괄호 `)`는 여는 괄호 `(`로 바꿉니다.
3.  **후위 표기법으로 변환**: 수정된 수식을 **후위 표기법으로 변환**합니다. (`infix_2_postfix` 함수 사용)
4.  **결과 뒤집기**: 후위 표기법으로 변환된 결과를 다시 뒤집습니다. 이 최종 결과가 바로 원본 중위 표기법의 전위 표기법 형태가 됩니다.

**예시: `a + b ^ c`**
1.  **수식 뒤집기**: `c ^ b + a`
2.  **괄호 뒤집기**: (괄호가 없으므로 변화 없음)
3.  **후위 변환**: `c ^ b + a` -> `c b ^ a +`
4.  **결과 뒤집기**: `+ a ^ b c`

따라서, `a + b ^ c` (중위) -> `+ a ^ b c` (전위) 로 변환됩니다.

## 3. 함수 설명

### `infix_2_postfix(Infix: str) -> str`

-   **역할**: 중위 표기법 문자열 `Infix`를 후위 표기법 문자열로 변환합니다. 이 함수는 `infix_to_postfix_conversion.py`의 션팅 야드(Shunting-yard) 알고리즘과 거의 동일한 로직을 가집니다.
-   **특징**: 변환 과정을 단계별로 테이블 형태로 출력하여 알고리즘의 동작을 시각적으로 보여줍니다.

### `infix_2_prefix(Infix: str) -> str`

-   **역할**: 중위 표기법 문자열 `Infix`를 전위 표기법 문자열로 변환합니다.
-   **매개변수**:
    -   `Infix`: 변환할 중위 표기법 수식.
-   **시간 복잡도**: O(N), 여기서 N은 문자열의 길이입니다. 문자열을 여러 번 순회하지만 모두 선형 시간입니다.
-   **공간 복잡도**: O(N), 후위 변환 과정에서 스택을 사용합니다.
-   **동작**: 위에서 설명한 "후위 표기법 변환 응용" 알고리즘을 그대로 구현합니다.

## 4. 사용 예제

스크립트를 직접 실행하면 사용자로부터 중위 표기법 수식을 입력받아 전위 표기법으로 변환하고, 그 과정을 테이블로 출력합니다.

**실행:**
```bash
python /home/kjrock/work2/study/kjrock100/python_study2/TheAlgorithms/data_structures/stacks/infix_to_prefix_conversion.py
```

**입력:**
```
Enter an Infix Equation = a + b ^c
```

**출력:**
```
 Symbol  |  Stack  | Postfix
----------------------------
   c     |         | c
   ^     | ^       | c
   b     | ^       | cb
   +     | +       | cb^
   a     | +       | cb^a
         |         | cb^a+

         a+b^c (Infix) ->  +a^bc (Prefix)
```

## 5. 코드의 한계 및 개선점

-   **모듈 의존성**: 이 코드는 `infix_2_postfix` 함수를 자체적으로 정의하고 있어, 다른 파일(`infix_to_postfix_conversion.py`)에 대한 의존성이 없습니다. 하지만 이름과 기능이 중복되므로, 모듈로 분리하여 재사용성을 높이는 것이 좋습니다.
-   **가독성**: `infix_2_postfix` 함수 내의 `print` 문들이 핵심 로직과 섞여 있어 가독성을 해칠 수 있습니다. 로깅이나 디버깅 기능은 별도의 함수나 플래그로 분리하는 것이 좋습니다.
-   **입력 처리**: 현재 코드는 한 글자로 된 피연산자만 처리할 수 있습니다. 여러 자리 숫자나 실수를 처리하려면 토큰화(tokenization) 과정이 필요합니다.

## 6. 테스트

이 스크립트에는 별도의 `doctest`나 `unittest`가 포함되어 있지 않지만, `if __name__ == "__main__":` 블록의 예제 실행을 통해 기본적인 동작을 확인할 수 있습니다.