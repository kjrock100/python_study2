# `evaluate_postfix_notations.py` 코드 설명

이 문서는 `evaluate_postfix_notations.py` 스크립트에 구현된, 후위 표기법(Postfix Notation)으로 작성된 수식을 계산하는 알고리즘에 대해 설명합니다.

## 1. 후위 표기법(Postfix Notation)이란?

후위 표기법은 연산자를 피연산자 뒤에 쓰는 표기 방식입니다. 역폴란드 표기법(Reverse Polish Notation, RPN)이라고도 불립니다.

-   **중위 표기법 (Infix)**: `3 + 4`
-   **후위 표기법 (Postfix)**: `3 4 +`

후위 표기법의 가장 큰 장점은 괄호나 연산자 우선순위 규칙 없이도 수식을 계산할 수 있다는 점입니다. 이는 스택(Stack) 자료 구조를 사용하여 매우 간단하게 구현할 수 있습니다.

## 2. 핵심 알고리즘: 스택(Stack) 활용

이 코드는 **스택(Stack)** 자료 구조를 사용하여 후위 표기법 수식을 계산합니다.

**동작 원리:**
1.  빈 스택을 생성합니다.
2.  입력된 후위 표기법 리스트를 왼쪽에서 오른쪽으로 순회합니다.
3.  **토큰이 피연산자(숫자)이면**: 스택에 `push`합니다.
4.  **토큰이 연산자(+, -, *, /)이면**:
    -   스택에서 피연산자 두 개를 `pop`합니다. (먼저 `pop`된 것이 두 번째 피연산자, 나중에 `pop`된 것이 첫 번째 피연산자입니다.)
    -   두 피연산자에 대해 해당 연산을 수행합니다.
    -   연산 결과를 다시 스택에 `push`합니다.
5.  리스트 순회가 끝나면, 스택에 마지막으로 남아있는 하나의 값이 최종 결과입니다.

## 3. 함수 설명

### `evaluate_postfix(postfix_notation: list) -> int`

-   **역할**: 후위 표기법으로 표현된 토큰 리스트 `postfix_notation`을 계산하고, 그 결과를 정수로 반환합니다.
-   **매개변수**:
    -   `postfix_notation`: 피연산자(문자열 형태의 숫자)와 연산자로 구성된 리스트.
-   **시간 복잡도**: O(N), 여기서 N은 토큰의 개수입니다. 리스트를 한 번만 순회합니다.
-   **공간 복잡도**: O(N), 최악의 경우 모든 피연산자가 스택에 저장될 수 있습니다.

### 특별한 나눗셈 처리

```python
if a * b < 0 and a % b != 0:
    stack.append(a // b + 1)
else:
    stack.append(a // b)
```
이 코드는 파이썬의 정수 나눗셈(`//`) 동작을 C언어 스타일(0을 향해 버림)로 맞추기 위한 부분입니다.
-   파이썬에서 `-6 // 5`는 `-2`가 됩니다 (음의 무한대 방향으로 버림).
-   하지만 많은 프로그래밍 문제 플랫폼에서는 `-6 / 5`의 정수 결과로 `-1`을 기대합니다 (0을 향해 버림).
-   위 코드는 음수 나눗셈에서 나머지가 있을 경우, 결과에 1을 더하여 0을 향해 버리는 효과를 냅니다.

## 4. 사용 예제

`doctest`에 포함된 예제는 이 함수의 사용법을 보여줍니다.

**예제 1:** `["2", "1", "+", "3", "*"]`
1.  `2` push -> stack: `[2]`
2.  `1` push -> stack: `[2, 1]`
3.  `+` 만남 -> pop 1, pop 2 -> `2 + 1 = 3` -> `3` push -> stack: `[3]`
4.  `3` push -> stack: `[3, 3]`
5.  `*` 만남 -> pop 3, pop 3 -> `3 * 3 = 9` -> `9` push -> stack: `[9]`
6.  최종 결과: `9`

```python
>>> evaluate_postfix(["2", "1", "+", "3", "*"])
9
```

**예제 2:** `["4", "13", "5", "/", "+"]`
1.  `4` push -> stack: `[4]`
2.  `13` push -> stack: `[4, 13]`
3.  `5` push -> stack: `[4, 13, 5]`
4.  `/` 만남 -> pop 5, pop 13 -> `13 // 5 = 2` -> `2` push -> stack: `[4, 2]`
5.  `+` 만남 -> pop 2, pop 4 -> `4 + 2 = 6` -> `6` push -> stack: `[6]`
6.  최종 결과: `6`

```python
>>> evaluate_postfix(["4", "13", "5", "/", "+"])
6
```

## 5. 테스트 실행

파일에 포함된 `doctest`를 실행하여 코드의 정확성을 검증할 수 있습니다. 터미널에서 다음 명령어를 실행하세요.

```bash
python -m doctest /home/kjrock/work2/study/kjrock100/python_study2/TheAlgorithms/data_structures/stacks/evaluate_postfix_notations.py
```

테스트가 모두 통과하면 아무런 출력도 나타나지 않습니다.