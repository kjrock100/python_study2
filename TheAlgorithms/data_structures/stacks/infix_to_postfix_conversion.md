# `infix_to_postfix_conversion.py` 코드 설명

이 문서는 `infix_to_postfix_conversion.py` 스크립트에 구현된, 중위 표기법(Infix Notation) 수식을 후위 표기법(Postfix Notation)으로 변환하는 알고리즘에 대해 설명합니다.

## 1. 중위 표기법과 후위 표기법

-   **중위 표기법 (Infix Notation)**: 우리가 일상적으로 사용하는 수식 표기법으로, 연산자가 피연산자 사이에 위치합니다. (예: `a + b`)
-   **후위 표기법 (Postfix Notation)**: 역폴란드 표기법(Reverse Polish Notation, RPN)이라고도 불리며, 연산자가 피연산자 뒤에 위치합니다. (예: `a b +`)

후위 표기법의 가장 큰 장점은 괄호나 연산자 우선순위 규칙 없이도, 스택을 이용하여 수식을 간단하게 계산할 수 있다는 점입니다. 이 스크립트는 중위 표기법을 후위 표기법으로 변환하는 역할을 합니다.

## 2. 핵심 알고리즘: 션팅 야드(Shunting-yard) 알고리즘

이 코드는 다익스트라(Dijkstra)가 고안한 **션팅 야드(Shunting-yard) 알고리즘**을 사용하여 변환을 수행합니다. 이 알고리즘은 스택을 이용하여 연산자의 우선순위를 처리하고 괄호를 제거합니다.

**동작 원리:**
1.  빈 스택(연산자용)과 빈 리스트(최종 결과용)를 생성합니다.
2.  입력된 중위 표기법 문자열을 왼쪽에서 오른쪽으로 순회합니다.
3.  **토큰이 피연산자(숫자 또는 문자)이면**: 결과 리스트에 바로 추가합니다.
4.  **토큰이 여는 괄호 `(`이면**: 스택에 `push`합니다.
5.  **토큰이 닫는 괄호 `)`이면**: 스택에서 여는 괄호 `(`가 나올 때까지 연산자를 계속 `pop`하여 결과 리스트에 추가합니다. 마지막으로 여는 괄호 `(`를 스택에서 `pop`하여 버립니다.
6.  **토큰이 연산자이면**:
    -   스택이 비어있지 않고, 스택의 맨 위(peek)에 있는 연산자의 우선순위가 현재 연산자의 우선순위보다 높거나 같으면, 스택에서 연산자를 `pop`하여 결과 리스트에 추가합니다. 이 과정을 조건이 만족하는 동안 반복합니다.
    -   위 과정이 끝나면, 현재 연산자를 스택에 `push`합니다.
7.  문자열 순회가 끝나면, 스택에 남아있는 모든 연산자를 `pop`하여 결과 리스트에 추가합니다.

## 3. 함수 설명

### `precedence(char: str) -> int`

-   **역할**: 주어진 연산자 문자(`char`)의 우선순위를 정수 값으로 반환합니다.
-   **우선순위**: `^` (3) > `*`, `/` (2) > `+`, `-` (1). 그 외 문자는 -1을 반환합니다.

### `infix_to_postfix(expression_str: str) -> str`

-   **역할**: 중위 표기법 문자열 `expression_str`을 후위 표기법 문자열로 변환합니다.
-   **매개변수**:
    -   `expression_str`: 변환할 중위 표기법 수식.
-   **시간 복잡도**: O(N), 여기서 N은 문자열의 길이입니다. 문자열을 한 번만 순회합니다.
-   **공간 복잡도**: O(N), 최악의 경우 스택에 대부분의 연산자를 저장해야 할 수 있습니다.
-   **사전 검사**: 변환을 시작하기 전에 `balanced_parentheses` 함수를 호출하여 입력된 수식의 괄호가 유효한지 먼저 확인합니다. 유효하지 않으면 `ValueError`를 발생시킵니다.

## 4. 사용 예제

`doctest`와 `if __name__ == "__main__"` 블록에 다양한 사용 예제가 포함되어 있습니다.

**예제: `(3+4)*5-6`**
1.  `(`: 스택에 push. `stack: [(`
2.  `3`: 결과에 추가. `postfix: [3]`
3.  `+`: 스택에 push. `stack: [(, +]`
4.  `4`: 결과에 추가. `postfix: [3, 4]`
5.  `)`: `+`를 pop하여 결과에 추가, `(`를 pop하여 버림. `postfix: [3, 4, +]`, `stack: []`
6.  `*`: 스택에 push. `stack: [*]`
7.  `5`: 결과에 추가. `postfix: [3, 4, +, 5]`
8.  `-`: 스택의 `*`가 `-`보다 우선순위가 높으므로, `*`를 pop하여 결과에 추가. 그 후 `-`를 push. `postfix: [3, 4, +, 5, *]`, `stack: [-]`
9.  `6`: 결과에 추가. `postfix: [3, 4, +, 5, *, 6]`
10. 순회 종료. 스택에 남은 `-`를 pop하여 결과에 추가. `postfix: [3, 4, +, 5, *, 6, -]`
11. 최종 결과: `"3 4 + 5 * 6 -"`

```python
>>> infix_to_postfix("(3+4)*5-6")
'3 4 + 5 * 6 -'

>>> infix_to_postfix("a+b*c+(d*e+f)*g")
'a b c * + d e * f + g * +'
```

## 5. 테스트 실행

파일에 포함된 `doctest`를 실행하여 코드의 정확성을 검증할 수 있습니다. 터미널에서 다음 명령어를 실행하세요.

```bash
python -m doctest /home/kjrock/work2/study/kjrock100/python_study2/TheAlgorithms/data_structures/stacks/infix_to_postfix_conversion.py
```

테스트가 모두 통과하면 아무런 출력도 나타나지 않습니다.