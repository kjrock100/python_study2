# `next_greater_element.py` 코드 설명

이 문서는 `next_greater_element.py` 스크립트에 구현된, 배열의 각 원소에 대한 "다음으로 큰 원소(Next Greater Element, NGE)"를 찾는 세 가지 다른 알고리즘에 대해 설명합니다.

## 1. 문제 설명: 다음으로 큰 원소 (NGE)

주어진 배열에서 각 원소 `x`에 대해, `x`의 오른쪽에 있으면서 `x`보다 큰 첫 번째 원소를 "다음으로 큰 원소"라고 합니다. 만약 그러한 원소가 존재하지 않으면, NGE는 -1입니다.

**예시:**
-   배열: `[4, 5, 2, 10]`
-   결과: `[5, 10, 10, -1]`
    -   4의 NGE는 5입니다.
    -   5의 NGE는 10입니다.
    -   2의 NGE는 10입니다.
    -   10의 NGE는 없습니다 (-1).

이 스크립트는 이 문제를 세 가지 다른 효율성의 함수로 해결합니다.

## 2. 알고리즘 설명

### 2.1. `next_greatest_element_slow(arr: list[float]) -> list[float]`

-   **접근 방식**: 가장 간단하고 직관적인 방법으로, 이중 반복문(nested loops)을 사용합니다.
-   **시간 복잡도**: O(N^2)
-   **공간 복잡도**: O(N) (결과를 저장하기 위한 리스트)

-   **동작 원리**:
    1.  바깥쪽 루프는 배열의 각 원소 `arr[i]`를 순회합니다.
    2.  안쪽 루프는 `arr[i]`의 오른쪽(`j` = `i+1`부터)을 순회하며 `arr[i]`보다 큰 첫 번째 원소 `arr[j]`를 찾습니다.
    3.  찾으면 그 값을 `next`로 설정하고 안쪽 루프를 중단합니다.
    4.  찾지 못하면 `next`는 초기값인 -1을 유지합니다.
    5.  `next` 값을 결과 리스트에 추가합니다.

### 2.2. `next_greatest_element_fast(arr: list[float]) -> list[float]`

-   **접근 방식**: `slow` 버전과 로직은 동일하지만, 파이썬의 `enumerate`와 리스트 슬라이싱을 사용하여 코드를 좀 더 간결하게 작성했습니다.
-   **시간 복잡도**: O(N^2)
-   **공간 복잡도**: O(N)

-   **동작 원리**:
    -   `for i, outer in enumerate(arr)`: 인덱스와 값을 동시에 가져옵니다.
    -   `for inner in arr[i + 1 :]`: 안쪽 루프에서 리스트 슬라이싱을 사용하여 `i` 이후의 부분만 순회합니다.
    -   성능상으로는 `slow` 버전과 큰 차이가 없지만, 코드가 더 파이썬스럽습니다(Pythonic).

### 2.3. `next_greatest_element(arr: list[float]) -> list[float]`

-   **접근 방식**: **스택(Stack)**을 사용하여 시간 복잡도를 크게 개선한 효율적인 방법입니다.
-   **시간 복잡도**: O(N) - 각 원소는 스택에 최대 한 번씩 `push`되고 `pop`됩니다.
-   **공간 복잡도**: O(N) (결과 리스트와 스택)

-   **동작 원리**:
    1.  빈 스택과 -1로 채워진 결과 리스트를 생성합니다.
    2.  배열을 **오른쪽에서 왼쪽으로** (역순으로) 순회합니다.
    3.  현재 원소 `arr[index]`에 대해, 스택의 맨 위(top)에 있는 값이 현재 원소보다 작거나 같으면, 스택에서 계속 `pop`합니다. (현재 원소의 오른쪽에 있으면서 더 작은 값들은 NGE가 될 수 없으므로 제거합니다.)
    4.  위 과정이 끝난 후:
        -   스택이 비어있지 않으면, 스택의 맨 위에 있는 값이 바로 현재 원소의 NGE입니다. 결과 리스트의 해당 위치에 이 값을 저장합니다.
        -   스택이 비어있으면, NGE가 없다는 의미이므로 결과 리스트는 초기값 -1을 유지합니다.
    5.  현재 원소를 스택에 `push`합니다. (이후에 순회할 왼쪽 원소들의 잠재적인 NGE가 될 수 있습니다.)
    6.  배열 순회가 끝나면 결과 리스트를 반환합니다.

## 3. 성능 비교

`if __name__ == "__main__"` 블록에서는 `timeit` 모듈을 사용하여 세 함수의 실행 시간을 비교합니다.

```
next_greatest_element_slow(): 1.73...
next_greatest_element_fast(): 1.54...
     next_greatest_element(): 0.89...
```

결과에서 볼 수 있듯이, 스택을 사용한 O(N) 솔루션(`next_greatest_element`)이 이중 루프를 사용한 O(N^2) 솔루션들보다 훨씬 빠릅니다.

## 4. 테스트 실행

파일에 포함된 `doctest`를 실행하여 코드의 정확성을 검증할 수 있습니다. 터미널에서 다음 명령어를 실행하세요.

```bash
python -m doctest /home/kjrock/work2/study/kjrock100/python_study2/TheAlgorithms/data_structures/stacks/next_greater_element.py
```

테스트가 모두 통과하면 아무런 출력도 나타나지 않습니다.