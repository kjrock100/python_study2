# `is_palindrome.py` 코드 설명

이 문서는 `is_palindrome.py` 스크립트에 구현된, 단일 연결 리스트(Singly Linked List)가 회문(Palindrome)인지 판별하는 세 가지 다른 알고리즘에 대해 설명합니다.

## 1. 문제 설명: 연결 리스트 회문 판별

회문은 앞에서부터 읽으나 뒤에서부터 읽으나 동일한 문자열이나 시퀀스를 의미합니다. (예: "level", "racecar")

이 문제의 목표는 주어진 단일 연결 리스트가 회문 구조를 가지고 있는지 확인하는 것입니다. 예를 들어, `1 -> 2 -> 3 -> 2 -> 1`은 회문이지만, `1 -> 2 -> 3`은 회문이 아닙니다.

이 스크립트는 세 가지 다른 접근 방식을 제공합니다.

1.  **리스트 뒤집기 (In-place Reversal)**
2.  **스택 사용 (Stack)**
3.  **딕셔너리 사용 (Dictionary)**

> **참고**: 이 코드들은 연결 리스트의 `head` 노드를 인자로 받으며, 각 노드는 `val` 속성과 `next` 속성을 가지고 있다고 가정합니다.

## 2. 알고리즘 설명

### 2.1. `is_palindrome(head)` - 리스트 뒤집기 방식

이 함수는 연결 리스트의 절반을 직접 뒤집어 나머지 절반과 비교하는 가장 효율적인 공간 복잡도를 가진 방법입니다.

-   **시간 복잡도**: O(N)
-   **공간 복잡도**: O(1)

-   **동작 원리**:
    1.  **중간점 찾기**: '토끼와 거북이' 알고리즘을 사용합니다. `fast` 포인터는 두 칸씩, `slow` 포인터는 한 칸씩 이동합니다. `fast`가 리스트 끝에 도달하면 `slow`는 리스트의 중간 지점에 위치하게 됩니다.
    2.  **후반부 뒤집기**: `slow` 포인터 다음부터 시작하는 리스트의 후반부를 뒤집습니다.
    3.  **비교**: 원래 리스트의 처음(`head`)부터 시작하는 포인터와, 뒤집힌 후반부 리스트의 처음부터 시작하는 포인터를 동시에 이동시키며 각 노드의 값을 비교합니다.
    4.  하나라도 값이 다르면 `False`를 반환하고, 비교가 끝까지 성공하면 `True`를 반환합니다.

### 2.2. `is_palindrome_stack(head)` - 스택 사용 방식

이 함수는 스택(Stack) 자료 구조를 이용하여 구현이 비교적 간단한 방법입니다.

-   **시간 복잡도**: O(N)
-   **공간 복잡도**: O(N) (리스트의 절반을 스택에 저장)

-   **동작 원리**:
    1.  **중간점 찾기**: 위와 동일하게 '토끼와 거북이' 알고리즘으로 리스트의 중간 지점(`slow`)을 찾습니다.
    2.  **후반부 저장**: `slow` 포인터부터 리스트의 끝까지 모든 노드의 값을 스택에 넣습니다.
    3.  **비교**: 리스트의 처음(`head`)부터 시작하는 포인터(`cur`)를 이동시키면서, 스택에서 값을 하나씩 꺼내(`pop`) 비교합니다.
    4.  하나라도 값이 다르면 `False`를 반환하고, 스택이 빌 때까지 비교가 성공하면 `True`를 반환합니다.

### 2.3. `is_palindrome_dict(head)` - 딕셔너리 사용 방식

이 함수는 딕셔너리를 사용하여 각 값의 위치를 저장하고, 위치의 대칭성을 검사하는 독특한 방법입니다.

-   **시간 복잡도**: O(N)
-   **공간 복잡도**: O(N) (모든 노드의 값과 위치를 딕셔너리에 저장)

-   **동작 원리**:
    1.  **위치 저장**: 리스트를 순회하며 `{'값': [위치1, 위치2, ...]}` 형태의 딕셔너리를 만듭니다.
    2.  **대칭성 검사**:
        -   각 값에 대해 저장된 위치 리스트를 확인합니다.
        -   리스트의 길이가 홀수인 경우는 최대 하나만 허용됩니다 (리스트의 정중앙 요소).
        -   리스트의 길이가 짝수인 경우, `v[i] + v[len(v) - 1 - i]`가 전체 리스트의 마지막 인덱스(`checksum`)와 같은지 확인하여 위치가 대칭적인지 검사합니다.
        -   대칭이 아니거나, 홀수 길이의 값 리스트가 두 개 이상이면 `False`를 반환합니다.
    3.  모든 검사를 통과하면 `True`를 반환합니다.

## 3. 알고리즘 비교

| 알고리즘             | 시간 복잡도 | 공간 복잡도 | 장점                               | 단점                                     |
| -------------------- | ----------- | ----------- | ---------------------------------- | ---------------------------------------- |
| **리스트 뒤집기**    | O(N)        | O(1)        | 공간 효율성이 가장 뛰어남.         | 구현이 상대적으로 복잡하고, 원본 리스트의 구조를 변경함. |
| **스택 사용**        | O(N)        | O(N)        | 구현이 직관적이고 이해하기 쉬움.   | O(N)의 추가 공간이 필요함.               |
| **딕셔너리 사용**    | O(N)        | O(N)        | 독특한 접근 방식.                  | 구현이 복잡하고, 다른 방법에 비해 비효율적일 수 있음. |

## 4. 사용 예제

이 함수들을 사용하려면, 먼저 연결 리스트를 생성해야 합니다.

```python
# 예시 Node 클래스
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None

# 1 -> 2 -> 2 -> 1 (회문)
head = Node(1)
head.next = Node(2)
head.next.next = Node(2)
head.next.next.next = Node(1)

print(is_palindrome(head))  # 출력: True
print(is_palindrome_stack(head)) # 출력: True
print(is_palindrome_dict(head)) # 출력: True
```

