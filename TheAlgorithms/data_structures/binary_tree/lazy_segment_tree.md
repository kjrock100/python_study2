# `lazy_segment_tree.py` 코드 설명

이 문서는 `lazy_segment_tree.py` 스크립트에 구현된 지연 전파 세그먼트 트리(Lazy Segment Tree)에 대해 설명합니다.

## 1. 지연 전파 세그먼트 트리란?

세그먼트 트리는 배열의 특정 구간에 대한 연산(예: 합, 곱, 최댓값, 최솟값)을 효율적으로 수행하는 자료 구조입니다. 일반적인 세그먼트 트리는 구간 쿼리(Query)와 단일 원소 업데이트(Update)를 모두 O(log N) 시간에 처리할 수 있습니다.

**지연 전파(Lazy Propagation)**는 여기에 **구간 업데이트(Range Update)** 기능까지 효율적으로 추가한 기법입니다. 특정 구간의 모든 원소를 변경해야 할 때, 실제로 모든 노드를 즉시 업데이트하는 대신 변경 사항을 특정 노드에 "지연"시켜 저장해 둡니다. 그리고 해당 노드나 그 자식 노드에 접근해야 할 때 비로소 지연된 업데이트를 전파하여 적용합니다.

이 기법을 통해 구간 업데이트 역시 O(log N)의 시간 복잡도로 수행할 수 있습니다.

이 구현은 **구간 최댓값 쿼리(Range Maximum Query)**와 **구간 값 변경 업데이트(Range Set-Value Update)**를 지원합니다.

## 2. 클래스 및 메서드 설명

### `SegmentTree` 클래스

#### `__init__(self, size: int)`
-   **역할**: 세그먼트 트리를 초기화합니다.
-   **속성**:
    -   `size`: 원본 배열의 크기.
    -   `segment_tree`: 각 노드의 구간별 최댓값을 저장하는 배열.
    -   `lazy`: 각 노드에 적용될 지연된 업데이트 값을 저장하는 배열.
    -   `flag`: 해당 노드에 지연된 업데이트가 있는지 여부를 표시하는 불리언(Boolean) 배열.

#### `build(self, idx, left_element, right_element, A)`
-   **역할**: 초기 배열 `A`를 기반으로 세그먼트 트리를 O(N) 시간에 구축합니다.
-   **동작**: 재귀적으로 배열을 반으로 나누어 각 구간의 최댓값을 계산하고 `segment_tree`에 저장합니다.

#### `update(self, idx, left_element, right_element, a, b, val)`
-   **역할**: `[a, b]` 구간의 모든 원소 값을 `val`로 업데이트합니다.
-   **시간 복잡도**: O(log N)
-   **동작 (지연 전파 핵심)**:
    1.  **지연 전파**: 현재 노드(`idx`)에 지연된 업데이트(`flag[idx] is True`)가 있다면, 그 값을 현재 노드에 적용하고 자식 노드로 전파합니다.
    2.  **구간 확인**:
        -   현재 노드의 구간이 업데이트 구간 `[a, b]`와 전혀 겹치지 않으면, 아무것도 하지 않고 종료합니다.
        -   현재 노드의 구간이 업데이트 구간 `[a, b]`에 완전히 포함되면, 현재 노드의 값을 `val`로 바꾸고, 자식 노드들에게는 `val`로 업데이트하라는 "지연" 플래그만 남깁니다. 그리고 재귀를 중단합니다.
        -   부분적으로만 겹치면, 자식 노드로 재귀 호출을 계속 진행합니다.
    3.  **값 갱신**: 재귀 호출이 끝난 후, 현재 노드의 값을 자식 노드들의 최댓값으로 갱신합니다.

#### `query(self, idx, left_element, right_element, a, b)`
-   **역할**: `[a, b]` 구간의 최댓값을 반환합니다.
-   **시간 복잡도**: O(log N)
-   **동작**:
    1.  **지연 전파**: `update`와 마찬가지로, 쿼리 시점에 지연된 업데이트가 있다면 먼저 적용하고 자식에게 전파합니다.
    2.  **구간 확인**:
        -   현재 노드의 구간이 쿼리 구간 `[a, b]`와 전혀 겹치지 않으면, 최댓값 계산에 영향을 주지 않는 매우 작은 값(`-math.inf`)을 반환합니다.
        -   현재 노드의 구간이 쿼리 구간 `[a, b]`에 완전히 포함되면, 현재 노드의 값(`segment_tree[idx]`)을 반환합니다.
        -   부분적으로만 겹치면, 자식 노드로 재귀 호출을 계속 진행하여 얻은 결과 중 더 큰 값을 반환합니다.

#### `__str__(self)`
-   **역할**: 현재 세그먼트 트리가 표현하는 배열의 상태를 문자열로 반환합니다. 내부적으로 각 인덱스 `i`에 대해 `query(i, i)`를 호출하여 값을 얻습니다.

## 3. 사용 예제

```python
if __name__ == "__main__":
    # 초기 배열
    A = [1, 2, -4, 7, 3, -5, 6, 11, -20, 9, 14, 15, 5, 2, -8]
    size = 15

    # 세그먼트 트리 생성 및 빌드
    segt = SegmentTree(size)
    segt.build(1, 1, size, A)

    # 구간 [4, 6]의 최댓값 쿼리
    # A[3]~A[5] -> (7, 3, -5) -> max is 7
    print(segt.query(1, 1, size, 4, 6))
    # 출력: 7

    # 구간 [7, 11]의 최댓값 쿼리
    # A[6]~A[10] -> (6, 11, -20, 9, 14) -> max is 14
    print(segt.query(1, 1, size, 7, 11))
    # 출력: 14

    # 구간 [7, 12]의 최댓값 쿼리
    # A[6]~A[11] -> (6, 11, -20, 9, 14, 15) -> max is 15
    print(segt.query(1, 1, size, 7, 12))
    # 출력: 15

    # 구간 [1, 3]의 값을 111로 업데이트
    segt.update(1, 1, size, 1, 3, 111)

    # 전체 구간 [1, 15]의 최댓값 쿼리
    print(segt.query(1, 1, size, 1, 15))
    # 출력: 111

    # 구간 [7, 8]의 값을 235로 업데이트
    segt.update(1, 1, size, 7, 8, 235)

    # 현재 배열 상태 출력
    print(segt)
    # 출력: [111.0, 111.0, 111.0, 7.0, 3.0, -5.0, 235.0, 235.0, -20.0, 9.0, 14.0, 15.0, 5.0, 2.0, -8.0]
```