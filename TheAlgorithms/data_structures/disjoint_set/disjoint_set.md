# `disjoint_set.py` 코드 설명

이 문서는 `disjoint_set.py` 스크립트에 구현된 서로소 집합(Disjoint Set) 또는 Union-Find 자료 구조에 대해 설명합니다. 이 구현은 각 원소를 `Node` 객체로 표현하는 방식을 사용합니다.

## 1. 서로소 집합(Disjoint Set)이란?

서로소 집합은 서로 중복되지 않는, 분리된 집합들의 모음을 표현하는 자료 구조입니다. 이 자료 구조는 주로 세 가지 연산을 효율적으로 지원합니다.

-   **MakeSet**: 새로운 원소를 포함하는 새로운 집합을 만듭니다. (이 코드에서는 `make_set` 함수)
-   **Find**: 특정 원소가 어떤 집합에 속해 있는지 찾습니다. (이 코드에서는 `find_set` 함수)
-   **Union**: 두 개의 집합을 하나의 집합으로 합칩니다. (이 코드에서는 `union_set` 함수)

이 구현은 **경로 압축(Path Compression)**과 **랭크를 이용한 합집합(Union by Rank)**이라는 두 가지 중요한 최적화 기법을 사용하여 매우 빠른 연산 속도를 보장합니다.

## 2. 최적화 기법

### 경로 압축 (Path Compression)
-   `find_set`을 실행할 때, 경로상의 모든 노드가 최종 부모(루트)를 직접 가리키도록 갱신합니다.
-   이를 통해 트리의 높이가 매우 낮게 유지되어, 다음 `Find` 연산 시 거의 O(1)에 가까운 시간 복잡도를 가집니다.

### 랭크를 이용한 합집합 (Union by Rank)
-   `union_set`을 실행할 때, 두 트리의 랭크(트리의 높이에 대한 추정치)를 비교합니다.
-   랭크가 낮은 트리를 랭크가 높은 트리에 붙여서 전체 트리의 높이가 불필요하게 증가하는 것을 방지합니다.

## 3. 클래스 및 함수 설명

### `Node` 클래스

-   **역할**: 집합의 각 원소를 표현하는 노드 객체입니다.
-   **속성**:
    -   `data`: 노드가 저장하는 실제 값.
    -   `rank`: 트리의 높이에 대한 상한값.
    -   `parent`: 부모 노드를 가리키는 참조.

### `make_set(x: Node) -> None`

-   **역할**: `x`를 유일한 원소로 하는 새로운 집합을 생성합니다.
-   **동작**: 노드 `x`의 부모를 자기 자신으로 설정하고, 랭크를 0으로 초기화합니다.

### `union_set(x: Node, y: Node) -> None`

-   **역할**: `x`가 속한 집합과 `y`가 속한 집합을 합칩니다.
-   **동작**:
    1.  `find_set`을 이용해 `x`와 `y`의 루트를 각각 찾습니다.
    2.  두 루트가 같다면, 이미 같은 집합이므로 아무것도 하지 않습니다.
    3.  **랭크를 이용한 합집합**:
        -   두 트리의 `rank`를 비교하여 랭크가 낮은 쪽을 높은 쪽에 붙입니다.
        -   만약 랭크가 같다면, 한쪽을 다른 쪽에 붙이고 루트가 된 쪽의 랭크를 1 증가시킵니다.

### `find_set(x: Node) -> Node`

-   **역할**: `x` 원소가 속한 집합의 대표(루트)를 찾습니다.
-   **동작**:
    1.  재귀적으로 부모를 따라 올라가 최종 루트를 찾습니다.
    2.  **경로 압축**: 이 과정에서 만나는 모든 노드의 `parent`를 최종 루트로 직접 갱신합니다.

## 4. 사용 예제 및 테스트

`test_disjoint_set` 함수는 이 자료 구조의 사용법을 보여줍니다.

```python
def test_disjoint_set() -> None:
    # 0부터 5까지의 값을 가진 6개의 노드 생성
    vertex = [Node(i) for i in range(6)]

    # 각 노드를 개별 집합으로 만듦
    for v in vertex:
        make_set(v)

    # {0}, {1}, {2}를 합쳐서 {0, 1, 2} 집합 생성
    union_set(vertex[0], vertex[1])
    union_set(vertex[1], vertex[2])

    # {3}, {4}, {5}를 합쳐서 {3, 4, 5} 집합 생성
    union_set(vertex[3], vertex[4])
    union_set(vertex[3], vertex[5])

    # 테스트: 같은 집합에 속한 노드들은 같은 대표를 가져야 함
    assert find_set(vertex[0]) == find_set(vertex[2])

    # 테스트: 다른 집합에 속한 노드들은 다른 대표를 가져야 함
    assert find_set(vertex[1]) != find_set(vertex[4])
```