# `alternate_disjoint_set.py` 코드 설명

이 문서는 `alternate_disjoint_set.py` 스크립트에 구현된 서로소 집합(Disjoint Set) 또는 Union-Find 자료 구조에 대해 설명합니다.

## 1. 서로소 집합(Disjoint Set)이란?

서로소 집합은 서로 중복되지 않는, 분리된 집합들의 모음을 표현하는 자료 구조입니다. 이 자료 구조는 주로 두 가지 연산을 효율적으로 지원합니다.

-   **Find**: 특정 원소가 어떤 집합에 속해 있는지 찾습니다. (이 코드에서는 `get_parent` 메서드)
-   **Union**: 두 개의 집합을 하나의 집합으로 합칩니다. (이 코드에서는 `merge` 메서드)

이 구현은 **경로 압축(Path Compression)**과 **랭크를 이용한 합집합(Union by Rank)**이라는 두 가지 중요한 최적화 기법을 사용하여 매우 빠른 연산 속도를 보장합니다.

## 2. 최적화 기법

### 경로 압축 (Path Compression)
-   `get_parent`를 실행할 때, 경로상의 모든 노드가 최종 부모(루트)를 직접 가리키도록 갱신합니다.
-   이를 통해 트리의 높이가 매우 낮게 유지되어, 다음 `Find` 연산 시 거의 O(1)에 가까운 시간 복잡도를 가집니다.

### 랭크를 이용한 합집합 (Union by Rank)
-   `merge`를 실행할 때, 두 트리의 랭크(트리의 높이에 대한 추정치)를 비교합니다.
-   랭크가 낮은 트리를 랭크가 높은 트리에 붙여서 전체 트리의 높이가 불필요하게 증가하는 것을 방지합니다.

## 3. 클래스 및 메서드 설명

### `DisjointSet` 클래스

#### `__init__(self, set_counts: list)`
-   **역할**: 서로소 집합 자료 구조를 초기화합니다.
-   **매개변수**:
    -   `set_counts`: 각 초기 집합에 포함된 원소의 개수를 담은 리스트.
-   **속성**:
    -   `set_counts`: 각 집합의 크기를 저장하는 리스트.
    -   `max_set`: 현재까지 합쳐진 집합 중 가장 큰 집합의 크기.
    -   `ranks`: 각 집합의 랭크를 저장하는 리스트 (초기값은 모두 1).
    -   `parents`: 각 원소의 부모를 저장하는 리스트 (초기에는 자기 자신을 부모로 가짐).

#### `get_parent(self, disj_set: int) -> int`
-   **역할**: `disj_set` 원소가 속한 집합의 대표(루트)를 찾습니다.
-   **동작**:
    1.  재귀적으로 부모를 따라 올라가 최종 루트를 찾습니다.
    2.  **경로 압축**: 이 과정에서 만나는 모든 노드의 `parent`를 최종 루트로 직접 갱신합니다.

#### `merge(self, src: int, dst: int) -> bool`
-   **역할**: `src`가 속한 집합과 `dst`가 속한 집합을 합칩니다.
-   **동작**:
    1.  `get_parent`를 이용해 `src`와 `dst`의 루트를 각각 찾습니다.
    2.  두 루트가 같다면, 이미 같은 집합에 속해 있으므로 `False`를 반환합니다.
    3.  **랭크를 이용한 합집합**:
        -   두 트리의 `ranks`를 비교하여 랭크가 낮은 쪽을 높은 쪽에 붙입니다.
        -   만약 랭크가 같다면, 한쪽을 다른 쪽에 붙이고 루트가 된 쪽의 랭크를 1 증가시킵니다.
    4.  합쳐진 집합의 `set_counts`를 갱신하고, `max_set` 값을 필요에 따라 업데이트합니다.
    5.  성공적으로 합쳐지면 `True`를 반환합니다.

## 4. 사용 예제

코드에 포함된 `doctest`는 다음과 같은 사용법을 보여줍니다.

```python
# 각 1개의 원소를 가진 3개의 집합 {0}, {1}, {2}로 초기화
A = DisjointSet([1, 1, 1])

# 집합 1과 집합 2를 합침
# A.parents -> [0, 2, 2] (1의 부모가 2가 됨)
# A.set_counts -> [1, 0, 2]
>>> A.merge(1, 2)
True

# 집합 0과 집합 2를 합침
# A.parents -> [2, 2, 2] (0의 부모가 2가 됨)
# A.set_counts -> [0, 0, 3]
>>> A.merge(0, 2)
True

# 집합 0과 1은 이미 같은 집합(대표: 2)에 속해 있으므로 합칠 수 없음
>>> A.merge(0, 1)
False

# 0의 대표 찾기 (경로 압축이 일어날 수 있음)
>>> A.get_parent(0)
2

# 1의 대표 찾기
>>> A.get_parent(1)
2
```

## 5. 테스트

스크립트에는 `doctest`가 포함되어 있어 코드의 정확성을 검증할 수 있습니다. 터미널에서 다음 명령어를 실행하여 테스트를 진행할 수 있습니다.

```bash
python -m doctest /home/kjrock/work2/study/kjrock100/python_study2/TheAlgorithms/data_structures/disjoint_set/alternate_disjoint_set.py
```

테스트가 성공하면 아무런 출력도 나타나지 않습니다.