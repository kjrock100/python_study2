# `trie.py` 코드 설명

이 문서는 `trie.py` 스크립트에 구현된 트라이(Trie) 또는 접두사 트리(Prefix Tree) 자료 구조에 대해 설명합니다.

## 1. 트라이(Trie)란?

트라이는 문자열 집합을 저장하고 빠르게 검색하기 위해 사용되는 트리 형태의 자료 구조입니다. 각 노드는 문자를 나타내며, 루트에서부터 특정 노드까지의 경로는 하나의 접두사(prefix)를 형성합니다.

**주요 특징:**
-   **빠른 검색**: 단어의 길이를 L이라고 할 때, 단어 검색, 삽입, 삭제 연산은 O(L)의 시간 복잡도를 가집니다. 이는 해시 테이블과 유사하지만, 접두사를 이용한 검색(예: 'ap'로 시작하는 모든 단어 찾기)에 훨씬 더 효율적입니다.
-   **공간 효율성**: 공통된 접두사를 가진 단어들은 같은 노드를 공유하므로, 많은 단어가 공통 접두사를 가질 경우 공간을 절약할 수 있습니다.
-   **단점**: 각 노드가 자식 노드에 대한 포인터(이 구현에서는 딕셔너리)를 유지해야 하므로, 저장되는 단어의 수가 적거나 공통 접두사가 거의 없는 경우 공간 낭비가 심할 수 있습니다.

## 2. 클래스 구조

이 구현에서는 `TrieNode` 클래스가 트라이 자체이자 동시에 트리를 구성하는 각 노드를 나타냅니다.

### `TrieNode` 클래스

#### `__init__(self)`
-   **역할**: 트라이 노드를 초기화합니다.
-   **속성**:
    -   `nodes: dict[str, TrieNode]`: 현재 노드의 자식 노드들을 저장하는 딕셔너리. 키는 문자(character)이고, 값은 해당 문자에 해당하는 `TrieNode` 객체입니다.
    -   `is_leaf: bool`: 현재 노드에서 끝나는 단어가 있는지를 나타내는 플래그. `True`이면, 루트부터 현재 노드까지의 경로가 하나의 완성된 단어임을 의미합니다.

## 3. 주요 메서드 설명

### `insert(self, word: str)`
-   **역할**: 트라이에 새로운 단어를 삽입합니다.
-   **시간 복잡도**: O(L) (L은 단어의 길이)
-   **동작**:
    1.  루트 노드(`self`)에서 시작합니다.
    2.  단어의 각 문자를 순회하며, 현재 노드의 `nodes` 딕셔너리에 해당 문자가 있는지 확인합니다.
    3.  문자가 없으면 새로운 `TrieNode`를 생성하여 추가하고, 있으면 기존 노드로 이동합니다.
    4.  단어의 마지막 문자에 해당하는 노드에 도달하면, `is_leaf`를 `True`로 설정하여 단어의 끝임을 표시합니다.

### `insert_many(self, words: list[str])`
-   **역할**: 여러 단어를 한 번에 트라이에 삽입합니다.
-   **동작**: 리스트의 각 단어에 대해 `insert` 메서드를 반복 호출합니다.

### `find(self, word: str) -> bool`
-   **역할**: 트라이에서 특정 단어가 완전한 형태로 존재하는지 검색합니다.
-   **시간 복잡도**: O(L) (L은 단어의 길이)
-   **동작**:
    1.  루트에서 시작하여 단어의 각 문자를 따라 노드를 이동합니다.
    2.  중간에 문자에 해당하는 자식 노드가 없으면, 단어가 존재하지 않는 것이므로 `False`를 반환합니다.
    3.  단어의 마지막 문자까지 성공적으로 도달했다면, 마지막 노드의 `is_leaf`가 `True`인지 확인하여 반환합니다. (`is_leaf`가 `False`이면 해당 단어는 다른 단어의 접두사일 뿐, 완전한 단어로 저장된 것은 아닙니다.)

### `delete(self, word: str)`
-   **역할**: 트라이에서 특정 단어를 삭제합니다.
-   **시간 복잡도**: O(L) (L은 단어의 길이)
-   **동작 (재귀)**:
    1.  `_delete` 헬퍼 함수를 재귀적으로 호출하여 단어의 끝까지 내려갑니다.
    2.  단어의 마지막 노드에 도달하면, `is_leaf`를 `False`로 변경합니다.
    3.  **가지치기(Pruning)**: 재귀에서 돌아오면서, 만약 현재 노드가 `is_leaf`가 아니고 자식 노드도 없다면, 이 노드는 더 이상 필요 없는 노드이므로 부모 노드에서 삭제합니다. 이 과정을 루트 방향으로 계속 진행합니다.

## 4. 유틸리티 및 테스트 함수

### `print_words(node: TrieNode, word: str)`
-   **역할**: 트라이에 저장된 모든 단어를 전위 순회(Pre-order traversal) 방식으로 출력합니다.

### `test_trie()`
-   **역할**: 트라이의 삽입, 검색, 삭제 기능이 올바르게 동작하는지 검증하는 테스트 함수입니다.

## 5. 사용 예제

`test_trie()` 함수는 이 클래스의 사용법을 잘 보여줍니다.

```python
# 트라이 루트 노드 생성
root = TrieNode()

# 단어들 삽입
words = "banana bananas bandana band apple all beast".split()
root.insert_many(words)

# 단어 검색
print(root.find("banana"))   # 출력: True
print(root.find("apple"))    # 출력: True
print(root.find("bandanas")) # 출력: False (s가 없음)

# 단어 삭제
root.delete("all")
print(root.find("all"))      # 출력: False

# 삭제 후 다른 단어 확인
root.delete("banana")
print(root.find("banana"))   # 출력: False (is_leaf가 False가 됨)
print(root.find("bananas"))  # 출력: True (bananas는 여전히 존재)
```

## 6. 테스트 실행

파일에 포함된 `doctest`와 `pytests()` 함수를 실행하여 코드의 정확성을 검증할 수 있습니다. 터미널에서 다음 명령어를 실행하세요.

```bash
python /home/kjrock/work2/study/kjrock100/python_study2/TheAlgorithms/data_structures/trie/trie.py
```

테스트가 모두 통과하면 `Testing trie functionality works!` 메시지가 출력됩니다.