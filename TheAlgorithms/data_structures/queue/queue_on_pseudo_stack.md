# `queue_on_pseudo_stack.py` 코드 설명

이 문서는 `queue_on_pseudo_stack.py` 스크립트에 구현된, 의사 스택(pseudo stack)을 이용한 큐(Queue) 자료 구조에 대해 설명합니다.

## 1. 개요

이 코드는 파이썬 리스트를 스택처럼 사용하여 큐(Queue)의 선입선출(FIFO) 동작을 흉내 내려고 시도합니다. 하지만 구현 방식이 매우 비효율적이어서 교육적인 목적 외에는 실제 사용에 적합하지 않습니다.

**핵심 아이디어**:
-   `put` (Enqueue): 리스트의 끝에 요소를 추가합니다 (`append`).
-   `get` (Dequeue): 큐를 여러 번 회전시켜 첫 번째 요소를 맨 뒤로 보낸 후, 리스트의 `pop`과 유사한 방식으로 제거하고, 다시 원래 순서로 되돌립니다.

## 2. 클래스 및 메서드 설명

### `Queue` 클래스

#### `__init__(self)`
-   **역할**: 빈 큐를 초기화합니다.
-   **속성**:
    -   `stack`: 실제 데이터가 저장되는 리스트.
    -   `length`: 현재 큐에 저장된 요소의 개수.

#### `put(self, item)`
-   **역할**: 큐의 끝에 새로운 `item`을 추가합니다.
-   **시간 복잡도**: O(1) (분할 상환 분석)
-   **동작**: 파이썬 리스트의 `append` 메서드를 사용합니다.

#### `rotate(self, rotation)`
-   **역할**: 큐를 `rotation` 횟수만큼 회전시킵니다. (앞에서 빼서 뒤로 넣음)
-   **성능 문제**: 이 메서드는 매우 비효율적입니다.
    -   `self.stack = self.stack[1:]` 부분은 리스트 슬라이싱으로, 리스트의 나머지 부분을 복사하여 새로운 리스트를 만듭니다. 이 연산은 **O(N)**의 시간 복잡도를 가집니다.
    -   이 연산을 `rotation` 횟수만큼 반복하므로, 전체 시간 복잡도는 **O(N * rotation)**이 됩니다.

#### `get(self)`
-   **역할**: 큐의 앞에서 요소를 제거하고 반환합니다.
-   **성능 문제**: 이 메서드는 `rotate`를 여러 번 호출하여 극도로 비효율적입니다.
    -   `self.rotate(1)`: O(N)
    -   `self.stack = self.stack[:-1]`: O(N)
    -   `self.rotate(self.length - 1)`: O(N * (N-1))
    -   전체적으로 **O(N^2)**의 매우 높은 시간 복잡도를 가집니다.

#### `front(self)`
-   **역할**: 큐의 첫 번째 요소를 삭제하지 않고 반환합니다.
-   **성능 문제**: 내부적으로 비효율적인 `get`과 `rotate`를 사용하므로, 이 메서드 역시 **O(N^2)**의 시간 복잡도를 가집니다.

#### `size(self)`
-   **역할**: 큐의 현재 크기를 반환합니다.
-   **시간 복잡도**: O(1)

## 3. 구현의 심각한 문제점 및 개선 방안

이 코드의 `get`, `rotate`, `front` 메서드는 리스트 슬라이싱을 반복적으로 사용하여 시간 복잡도가 매우 높습니다. 큐의 크기가 조금만 커져도 성능이 급격히 저하되어 사용할 수 없는 수준이 됩니다.

### 올바른 큐 구현 방법

1.  **`collections.deque` 사용 (가장 추천)**:
    -   파이썬 표준 라이브러리의 `collections.deque`는 이중 연결 리스트로 구현되어 있어, 양쪽 끝에서의 삽입(`append`)과 삭제(`popleft`)가 모두 **O(1)** 시간 복잡도를 보장합니다. 큐를 구현하는 가장 효율적이고 파이썬스러운(Pythonic) 방법입니다.

2.  **두 개의 스택 사용**:
    -   두 개의 스택(`in_stack`, `out_stack`)을 사용하여 큐를 구현할 수 있습니다. `put`은 `in_stack`에, `get`은 `out_stack`에서 수행합니다. `out_stack`이 비었을 때만 `in_stack`의 모든 요소를 `out_stack`으로 옮깁니다. 이 방식은 분할 상환 분석 시 **O(1)**의 시간 복잡도를 가집니다.

3.  **연결 리스트 사용**:
    -   `linked_queue.py`에서처럼 단일 연결 리스트와 `front`, `rear` 포인터를 사용하면 **O(1)** 시간 복잡도의 `put`과 `get`을 구현할 수 있습니다.

## 4. 사용 예제

```python
# 이 코드는 동작은 하지만 매우 느립니다.
q = Queue()

# 데이터 삽입
q.put(1)
q.put(2)
q.put(3)

print(q)
# 출력: <1, 2, 3>

# 데이터 추출
print(q.get())
# 출력: 1

print(q)
# 출력: <2, 3>

# 첫 번째 요소 확인
print(q.front())
# 출력: 2

print(q)
# 출력: <2, 3>
```