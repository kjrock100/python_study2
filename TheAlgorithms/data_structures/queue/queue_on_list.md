# `queue_on_list.py` 코드 설명

이 문서는 `queue_on_list.py` 스크립트에 구현된, 파이썬 리스트를 이용한 큐(Queue) 자료 구조에 대해 설명합니다.

## 1. 큐(Queue)란?

큐는 선입선출(First-In, First-Out, FIFO) 원칙을 따르는 선형 자료 구조입니다. 즉, 가장 먼저 추가된 요소가 가장 먼저 제거됩니다.

**주요 연산:**
-   **Enqueue**: 큐의 끝에 요소를 추가합니다. (이 코드에서는 `put` 메서드)
-   **Dequeue**: 큐의 앞에서 요소를 제거하고 반환합니다. (이 코드에서는 `get` 메서드)

## 2. 클래스 및 메서드 설명

### `Queue` 클래스

#### `__init__(self)`
-   **역할**: 빈 큐를 초기화합니다.
-   **속성**:
    -   `entries`: 실제 데이터가 저장되는 리스트.
    -   `length`: 현재 큐에 저장된 요소의 개수.
    -   `front`: 큐의 첫 번째 요소를 가리키는 인덱스. (현재 구현에서는 항상 0으로 유지되며, `get` 메서드에서 비효율을 유발합니다.)

#### `__str__(self)`
-   **역할**: 큐의 내용을 `< >`로 감싸서 문자열로 표현합니다.

#### `put(self, item)`
-   **역할**: 큐의 끝에 새로운 `item`을 추가합니다.
-   **시간 복잡도**: O(1) (분할 상환 분석)
-   **동작**: 파이썬 리스트의 `append` 메서드를 사용하여 리스트 끝에 요소를 추가하고, `length`를 1 증가시킵니다.

#### `get(self)`
-   **역할**: 큐의 앞에서 요소를 제거하고 반환합니다.
-   **성능 문제**: 이 메서드는 매우 비효율적으로 구현되어 있습니다.
    -   `self.entries = self.entries[1:]` 부분은 리스트의 첫 번째 요소를 제외한 새로운 리스트를 생성하고 다시 할당합니다. 이 과정은 리스트의 나머지 모든 요소를 복사해야 하므로 **O(N)**의 시간 복잡도를 가집니다. (N은 큐의 길이)
    -   이로 인해 큐가 길어질수록 `get` 연산의 성능이 급격히 저하됩니다.

#### `rotate(self, rotation)`
-   **역할**: 큐를 `rotation` 횟수만큼 회전시킵니다.
-   **동작**: `get`으로 앞에서 요소를 빼서 `put`으로 뒤에 넣는 과정을 반복합니다.
-   **성능 문제**: 내부적으로 비효율적인 `get` 메서드를 호출하므로, 이 메서드 역시 O(N * rotation)의 비효율적인 시간 복잡도를 가집니다.

#### `get_front(self)`
-   **역할**: 큐의 첫 번째 요소를 삭제하지 않고 반환합니다.
-   **시간 복잡도**: O(1)

#### `size(self)`
-   **역할**: 큐의 현재 크기(`length`)를 반환합니다.
-   **시간 복잡도**: O(1)

## 3. 구현의 한계 및 개선 방안

현재 구현은 `get` 메서드의 비효율성 때문에 실제 애플리케이션에서 사용하기에 적합하지 않습니다.

### 개선 방안

1.  **`collections.deque` 사용**: 파이썬 표준 라이브러리의 `collections.deque`는 이중 연결 리스트로 구현되어 있어, 양쪽 끝에서의 삽입(`append`)과 삭제(`popleft`)가 모두 O(1) 시간 복잡도를 보장합니다. 큐를 구현하는 가장 효율적이고 파이썬스러운(Pythonic) 방법입니다.

2.  **두 개의 스택 사용**: 두 개의 스택(`in_stack`, `out_stack`)을 사용하여 큐를 구현할 수 있습니다. `put`은 `in_stack`에, `get`은 `out_stack`에서 수행하며, `out_stack`이 비었을 때만 `in_stack`의 모든 요소를 `out_stack`으로 옮깁니다. 이 방식은 분할 상환 분석 시 O(1)의 시간 복잡도를 가집니다.

3.  **연결 리스트 사용**: `linked_queue.py`에서처럼 단일 연결 리스트와 `front`, `rear` 포인터를 사용하면 O(1) 시간 복잡도의 `put`과 `get`을 구현할 수 있습니다.

## 4. 사용 예제

```python
q = Queue()

# 데이터 삽입
q.put(1)
q.put(2)
q.put(3)

print(q)
# 출력: <1, 2, 3>

# 데이터 추출
print(q.get())
# 출력: 1

print(q)
# 출력: <2, 3>

# 큐 회전
q.rotate(1)
print(q)
# 출력: <3, 2>
```