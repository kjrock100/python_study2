# 최대 차이 쌍 구하기 (Max Difference Pair)

이 문서는 `max_difference_pair.py` 파일에 구현된 **최대 차이 쌍(Max Difference Pair)** 알고리즘에 대해 설명합니다. 이 문제는 정수 배열 $A$에서 $i \le j$를 만족하는 인덱스에 대해 $A[j] - A[i]$가 최대가 되는 두 원소를 찾는 것입니다.

## 개요

주식 거래 문제(최저가에 사서 최고가에 팔기)와 유사하며, 이 코드는 **분할 정복(Divide and Conquer)** 방식을 사용하여 해결합니다.

## 주요 함수: `max_difference(a)`

### `max_difference(a: list[int]) -> tuple[int, int]`
- **목적**: 주어진 리스트에서 차이가 최대가 되는 두 요소(작은 값, 큰 값)를 찾아 반환합니다.
- **매개변수**:
  - `a`: 정수 리스트.
- **반환값**: `(min_val, max_val)` 튜플. 여기서 `max_val - min_val`이 최대 차이가 됩니다.

### 알고리즘 동작 원리

1. **기저 사례 (Base Case)**:
   - 리스트의 길이가 1인 경우, 차이는 0이므로 해당 원소를 두 번 포함한 튜플을 반환합니다.

2. **분할 (Divide)**:
   - 리스트를 절반으로 나누어 `first`(왼쪽)와 `second`(오른쪽) 부분 리스트를 만듭니다.

3. **정복 (Conquer)**:
   - 재귀적으로 `first`와 `second` 각각에 대해 최대 차이 쌍을 구합니다.
   - `first`의 결과: `(small1, big1)`
   - `second`의 결과: `(small2, big2)`

4. **결합 (Combine)**:
   - 전체 리스트에서의 최대 차이는 다음 세 가지 경우 중 하나입니다.
     1. **왼쪽 부분 내부**: `big1 - small1`
     2. **오른쪽 부분 내부**: `big2 - small2`
     3. **걸쳐 있는 경우**: 오른쪽 부분의 최댓값(`max_second`) - 왼쪽 부분의 최솟값(`min_first`)
        - 조건 $i \le j$를 만족해야 하므로, 작은 값은 왼쪽에, 큰 값은 오른쪽에 있어야 합니다.
   - 위 세 가지 경우의 차이를 비교하여 가장 큰 차이를 만드는 쌍을 반환합니다.

## 시간 복잡도

- 각 단계에서 `min()`과 `max()` 함수를 사용하여 $O(n)$ 시간이 소요됩니다.
- 점화식: $T(n) = 2T(n/2) + O(n)$
- 따라서 전체 시간 복잡도는 **$O(n \log n)$**입니다.
- (참고: 선형 탐색을 이용하면 $O(n)$으로도 해결 가능하지만, 이 코드는 분할 정복 예제로서 작성되었습니다.)

## 사용법

`if __name__ == "__main__":` 블록은 `doctest`를 실행하여 함수가 올바르게 동작하는지 검증합니다.

예시:
```python
max_difference([5, 11, 2, 1, 7, 9, 0, 7])
# 결과: (1, 9) -> 차이: 8
# 설명: 1(인덱스 3)에 사서 9(인덱스 5)에 파는 것이 최대 이익
```
