# K번째 순서 통계량 (Kth Order Statistic)

이 문서는 `kth_order_statistic.py` 파일에 구현된 **K번째 순서 통계량** 알고리즘에 대해 설명합니다. 이 알고리즘은 정렬되지 않은 리스트에서 k번째로 작은 요소를 찾는 문제를 해결합니다.

## 개요

일반적으로 리스트를 정렬한 후 k번째 요소에 접근하면 $O(n \log n)$ 시간이 걸리지만, 분할 정복(Divide and Conquer) 방식을 사용하면 평균적으로 선형 시간($O(n)$) 내에 해결할 수 있습니다. 이 방식은 퀵 정렬(Quick Sort)의 파티셔닝 아이디어를 사용하며, **퀵 셀렉트(QuickSelect)**라고도 불립니다.

## 주요 함수 설명

### `random_pivot(lst)`
- **목적**: 리스트에서 무작위로 피벗(기준값)을 선택합니다.
- **이유**: 항상 첫 번째나 마지막 요소를 피벗으로 선택할 경우, 이미 정렬된 데이터에 대해 최악의 성능($O(n^2)$)을 보일 수 있습니다. 무작위 선택은 이를 방지하고 평균적인 성능을 보장하기 위함입니다.

### `kth_number(lst: list[int], k: int) -> int`
- **목적**: 리스트 `lst`에서 `k`번째로 작은 수를 반환합니다.
- **매개변수**:
  - `lst`: 정수 리스트.
  - `k`: 찾고자 하는 순위 (1부터 시작).
- **알고리즘 단계**:
  1. **피벗 선택**: `random_pivot` 함수를 통해 기준이 될 값을 정합니다.
  2. **분할 (Partitioning)**:
     - `small`: 피벗보다 작은 요소들의 리스트.
     - `big`: 피벗보다 큰 요소들의 리스트.
  3. **조건 검사 및 재귀**:
     - `len(small) == k - 1`: `small` 리스트에 `k-1`개의 요소가 있다는 것은, 피벗이 정확히 `k`번째 요소라는 의미입니다. 피벗을 반환합니다.
     - `len(small) < k - 1`: `k`번째 요소는 피벗보다 큰 그룹(`big`)에 존재합니다.
       - `big` 리스트에서 `k - len(small) - 1`번째 요소를 재귀적으로 찾습니다. (피벗과 `small` 그룹의 개수만큼 순위에서 제외)
     - `else` (`len(small) > k - 1`): `k`번째 요소는 피벗보다 작은 그룹(`small`)에 존재합니다.
       - `small` 리스트에서 `k`번째 요소를 재귀적으로 찾습니다.

## 사용법

`if __name__ == "__main__":` 블록은 `doctest` 모듈을 사용하여 함수 내의 예제 코드들이 올바르게 동작하는지 테스트합니다.

예시:
```python
kth_number([2, 1, 3, 4, 5], 3)
# 결과: 3 (1, 2, 3, 4, 5 중 3번째로 작은 수)

kth_number([25, 21, 98, 100, 76, 22, 43, 60, 89, 87], 4)
# 결과: 43 (21, 22, 25, 43, ... 순이므로 4번째는 43)
```

## 참고 사항

- 이 구현은 리스트 내에 중복된 요소가 없거나, 피벗과 같은 값이 하나뿐이라고 가정하는 단순화된 로직을 포함하고 있습니다. (피벗과 같은 값이 여러 개일 경우 `small`이나 `big`에 포함되지 않아 누락될 수 있음)
- 더 정교한 피벗 선택 알고리즘으로는 'Median of Medians' 알고리즘이 있습니다.
- 