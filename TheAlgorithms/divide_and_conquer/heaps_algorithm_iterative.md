# 힙의 알고리즘 (Heap's Algorithm) - 반복적 구현

이 문서는 `heaps_algorithm_iterative.py` 파일에 구현된 **힙의 알고리즘(Heap's Algorithm)**에 대해 설명합니다. 이 알고리즘은 주어진 리스트의 모든 가능한 순열(Permutation)을 생성하는 효율적인 방법 중 하나입니다.

## 개요

힙의 알고리즘은 요소의 이동을 최소화하여 순열을 생성합니다. 각 단계에서 두 요소만 교환(Swap)하여 이전 순열로부터 새로운 순열을 만들어냅니다. 이 파일은 재귀적 방식이 아닌 **반복적(Iterative)** 방식을 사용하여 구현되었습니다.

## 주요 함수: `heaps(arr)`

### `heaps(arr: list) -> list`
- **목적**: 입력된 리스트의 모든 순열을 생성하여 반환합니다.
- **매개변수**:
  - `arr`: 순열을 생성할 원소들이 담긴 리스트.
- **반환값**: 튜플(tuple) 형태의 순열들을 담은 리스트.

### 알고리즘 동작 원리

1. **초기화**:
   - 입력 리스트의 길이가 1 이하이면 그대로 반환합니다.
   - 상태를 추적하기 위한 카운터 배열 `c`를 0으로 초기화합니다. `c[i]`는 `i`번째 요소가 교환된 횟수를 나타냅니다.
   - 초기 배열 상태를 결과 리스트 `res`에 추가합니다.

2. **반복문 (`while i < n`)**:
   - `i`는 현재 처리 중인 인덱스를 나타냅니다.
   - **조건 검사**: `c[i] < i`인 경우 (아직 해당 인덱스에서 생성할 순열이 남음):
     - **교환(Swap)**:
       - `i`가 짝수이면: `arr[0]`과 `arr[i]`를 교환합니다.
       - `i`가 홀수이면: `arr[c[i]]`와 `arr[i]`를 교환합니다.
     - 새로운 순열을 결과 리스트에 추가합니다.
     - `c[i]`를 1 증가시키고, `i`를 0으로 리셋하여 다시 처음부터 검사합니다.
   - **조건 불만족**: `c[i] == i`인 경우 (해당 인덱스의 사이클 완료):
     - `c[i]`를 0으로 초기화하고 `i`를 1 증가시켜 다음 인덱스로 넘어갑니다.

## 사용법

`if __name__ == "__main__":` 블록에서 사용 예시를 확인할 수 있습니다:

1. 사용자로부터 쉼표(`,`)로 구분된 숫자들을 입력받습니다.
2. 입력 문자열을 정수 리스트로 변환합니다.
3. `heaps` 함수를 호출하여 모든 순열을 출력합니다.

예시:
```bash
Enter numbers separated by a comma:
1, 2, 3
[(1, 2, 3), (2, 1, 3), (3, 1, 2), (1, 3, 2), (2, 3, 1), (3, 2, 1)]
```
