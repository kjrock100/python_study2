# 역전 횟수 세기 (Counting Inversions)

이 문서는 `inversions.py` 파일에 구현된 **역전 횟수 세기(Counting Inversions)** 알고리즘에 대해 설명합니다.

## 개요

배열 $A$에서 인덱스 $i < j$일 때 $A[i] > A[j]$인 경우를 **역전(Inversion)**이라고 합니다. 역전의 총 개수는 배열이 얼마나 정렬되어 있는지를 나타내는 척도가 됩니다. 정렬된 배열은 역전이 0개이며, 역순으로 정렬된 배열은 최대 개수의 역전을 가집니다.

이 파일은 두 가지 방식의 알고리즘을 제공합니다:
1. **브루트 포스 (Brute Force)**: $O(n^2)$
2. **분할 정복 (Divide and Conquer)**: $O(n \log n)$

## 주요 함수 설명

### `count_inversions_bf(arr)`
- **목적**: 이중 반복문을 사용하여 모든 쌍을 비교하는 단순한 방식으로 역전 횟수를 셉니다.
- **매개변수**: `arr` (비교 가능한 요소들의 리스트).
- **반환값**: 총 역전 횟수.
- **시간 복잡도**: $O(n^2)$. 데이터가 많을 경우 비효율적입니다.

### `count_inversions_recursive(arr)`
- **목적**: 합병 정렬(Merge Sort)의 아이디어를 차용한 분할 정복 알고리즘으로 효율적으로 역전 횟수를 셉니다.
- **동작**:
  1. 배열을 절반으로 나눕니다 (`P`, `Q`).
  2. 재귀적으로 왼쪽 부분(`P`)과 오른쪽 부분(`Q`)의 역전 횟수를 구합니다.
  3. 두 부분 배열을 합병하면서 걸쳐 있는 역전(`cross_inversions`)을 셉니다.
  4. 전체 역전 횟수를 합산하여 반환합니다.
- **반환값**: (정렬된 배열, 총 역전 횟수) 튜플.
- **시간 복잡도**: $O(n \log n)$.

### `_count_cross_inversions(P, Q)`
- **목적**: 두 개의 정렬된 배열 `P`와 `Q`를 합병하면서, `P`의 원소가 `Q`의 원소보다 큰 경우(역전)를 셉니다.
- **원리**:
  - `P[i]`와 `Q[j]`를 비교합니다.
  - 만약 `P[i] > Q[j]`라면, `P`는 이미 정렬되어 있으므로 `P[i]` 뒤에 있는 모든 원소들도 `Q[j]`보다 큽니다.
  - 따라서 `len(P) - i`만큼 역전 횟수를 더하고, `Q[j]`를 결과 배열에 넣습니다.
  - 그렇지 않으면 `P[i]`를 결과 배열에 넣습니다.

## 사용법

`if __name__ == "__main__":` 블록에서 사용 예시를 확인할 수 있습니다:

1. 테스트 배열(`arr_1`)을 정의합니다.
2. `count_inversions_bf`와 `count_inversions_recursive`를 각각 호출하여 결과를 비교합니다.
3. 정렬된 배열과 빈 배열에 대해서도 테스트를 수행하여 정확성을 검증합니다.

```python
arr_1 = [10, 2, 1, 5, 5, 2, 11]
# 결과: 8개의 역전이 있음
```
