# 유니모달 리스트의 정점 찾기 (Finding Peak)

이 문서는 `peak.py` 파일에 구현된 **유니모달 리스트의 정점(Peak)**을 찾는 알고리즘에 대해 설명합니다.

## 개요

**유니모달(Unimodal) 리스트**란 특정 지점(인덱스 $p$)까지는 값이 계속 증가하다가, 그 이후로는 계속 감소하는 형태의 리스트를 말합니다. 이 알고리즘은 **분할 정복(Divide and Conquer)** 방식을 사용하여 리스트의 최댓값(정점)을 효율적으로 찾아냅니다.

일반적인 선형 탐색($O(n)$)보다 빠른, 이진 탐색과 유사한 $O(\log n)$의 논리적 시간 복잡도를 가집니다.

## 주요 함수: `peak(lst)`

### `peak(lst: list[int]) -> int`
- **목적**: 유니모달 리스트에서 정점(최댓값)을 찾아 반환합니다.
- **매개변수**:
  - `lst`: 유니모달 속성을 가진 정수 리스트.
- **알고리즘 동작 원리**:
  1. **중간 지점 선택**: 리스트의 중간 인덱스 `m`을 계산합니다.
  2. **주변 값 확인**: 중간 인덱스를 중심으로 3개의 요소(`m-1`, `m`, `m+1`)를 확인합니다 (`three = lst[m - 1 : m + 2]`).
  3. **조건 분기**:
     - **정점 발견**: 중간 값이 양옆의 값보다 크다면 (`three[1] > three[0]` and `three[1] > three[2]`), 해당 값이 정점입니다.
     - **증가하는 구간**: 오른쪽 값이 더 크다면 (`three[0] < three[2]`), 정점은 오른쪽에 존재합니다. 오른쪽 부분 리스트(`lst[m:]`)에 대해 재귀 호출합니다.
     - **감소하는 구간**: 왼쪽 값이 더 크다면, 정점은 왼쪽에 존재합니다. 왼쪽 부분 리스트(`lst[:m]`)에 대해 재귀 호출합니다.

## 코드 구현상의 특징

- **슬라이싱**: Python의 리스트 슬라이싱을 사용하여 재귀 호출 시 리스트를 잘라냅니다.
  - *참고*: Python에서 리스트 슬라이싱은 $O(k)$의 시간이 소요되므로, 엄밀한 의미에서의 시간 복잡도는 $O(n)$이 될 수 있습니다. 성능 최적화를 위해서는 인덱스(`low`, `high`)를 전달하는 방식을 사용하는 것이 좋습니다.
- **인덱스 조정**: 리스트가 작아질 때(`len(lst[:m]) == 2`) 인덱스 `m`을 조정하는 로직이 포함되어 있어, 슬라이싱 범위 오류를 방지합니다.

## 사용법

`if __name__ == "__main__":` 블록에서 `doctest`를 통해 다양한 케이스를 테스트합니다.

예시:
```python
peak([1, 2, 3, 4, 5, 4, 3, 2, 1])
# 결과: 5 (증가하다가 5에서 꺾여서 감소함)

peak([1, 10, 9, 8, 7])
# 결과: 10 (초반에 바로 정점이 나오는 경우)
```
