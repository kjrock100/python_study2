# 볼록 껍질 (Convex Hull)

이 문서는 `convex_hull.py` 파일에 구현된 **볼록 껍질(Convex Hull)** 알고리즘들에 대해 설명합니다. 볼록 껍질 문제는 2차원 평면상의 점들의 집합이 주어졌을 때, 모든 점을 포함하는 가장 작은 볼록 다각형을 찾는 기하학적 문제입니다.

## 개요

이 파일은 볼록 껍질을 찾기 위한 세 가지 다른 접근 방식을 구현하고 있습니다:
1. **브루트 포스 (Brute Force)**: $O(n^3)$
2. **분할 정복 (Divide and Conquer)**: $O(n \log n)$
3. **멜크만 알고리즘 (Melkman's Algorithm)**: $O(n \log n)$ (정렬된 경우 $O(n)$)

## 클래스 및 헬퍼 함수

### `Point` 클래스
- 2차원 좌표 $(x, y)$를 표현합니다.
- 비교 연산자(`__eq__`, `__lt__` 등)가 구현되어 있어 점들의 정렬 및 비교가 가능합니다.

### `_det(a, b, c)`
- **목적**: 두 점 $a, b$를 잇는 선분에 대해 점 $c$가 어느 위치에 있는지 판별합니다.
- **원리**: 외적(Cross Product)의 z-성분과 유사한 계산을 수행합니다.
  - 결과 > 0: 점 $c$가 선분 $ab$의 왼쪽(반시계 방향)에 있음.
  - 결과 < 0: 점 $c$가 선분 $ab$의 오른쪽(시계 방향)에 있음.
  - 결과 = 0: 세 점이 일직선상에 있음.

## 알고리즘 설명

### 1. `convex_hull_bf(points)`
- **방식**: 브루트 포스 (완전 탐색).
- **동작**:
  - 가능한 모든 두 점의 쌍 $(i, j)$를 선분으로 가정합니다.
  - 나머지 모든 점 $k$가 해당 선분의 한쪽(또는 선분 위)에만 존재하는지 확인합니다.
  - 조건을 만족하면 해당 선분은 볼록 껍질의 일부입니다.
- **성능**: 3중 반복문을 사용하므로 매우 느립니다 ($O(n^3)$).

### 2. `convex_hull_recursive(points)`
- **방식**: 분할 정복 (Divide and Conquer).
- **동작**:
  1. 점들을 x좌표 기준으로 정렬합니다.
  2. 가장 왼쪽 점과 가장 오른쪽 점을 잇는 선분을 기준으로 점들을 **위쪽 껍질(Upper Hull)** 후보와 **아래쪽 껍질(Lower Hull)** 후보로 나눕니다.
  3. 각 부분 집합에서 선분으로부터 가장 멀리 떨어진 점을 찾아 껍질에 추가하고, 다시 영역을 나누어 재귀적으로 수행합니다.
- **성능**: 일반적인 경우 $O(n \log n)$의 성능을 보입니다.

### 3. `convex_hull_melkman(points)`
- **방식**: 멜크만 알고리즘.
- **동작**:
  - 덱(Deque) 자료구조를 사용하여 볼록 껍질을 구성하는 점들을 관리합니다.
  - 점들을 순차적으로 처리하면서, 현재 껍질의 볼록성을 해치는 점들을 덱의 앞뒤에서 제거하고 새로운 점을 추가합니다.
  - 단순 다각형(Simple Polygon)이나 이미 정렬된 점들에 대해서는 $O(n)$의 속도로 동작할 수 있는 매우 효율적인 알고리즘입니다.

## 사용법

`if __name__ == "__main__":` 블록에서 사용 예시를 확인할 수 있습니다:

1. 테스트할 점들의 리스트를 정의합니다.
2. `convex_hull_bf`, `convex_hull_recursive`, `convex_hull_melkman` 함수를 각각 호출하여 결과를 얻습니다.
3. 각 알고리즘의 결과가 동일한지(`assert`) 확인하고 결과를 출력합니다.
