# SHA-1 해시 알고리즘 (SHA-1 Hash Algorithm)

이 문서는 `sha1.py` 파일에 구현된 **SHA-1 (Secure Hash Algorithm 1)** 에 대해 설명합니다.

## 개요

SHA-1은 임의의 길이의 입력을 받아 160비트(20바이트)의 고정된 길이의 해시값(메시지 다이제스트)을 출력하는 암호화 해시 함수입니다. 일반적으로 40자리의 16진수 문자열로 표현됩니다. 현재는 충돌 저항성 취약점이 발견되어 보안이 중요한 애플리케이션에서는 SHA-256 이상의 알고리즘 사용이 권장되지만, 여전히 학습 및 레거시 시스템 호환성을 위해 중요한 알고리즘입니다.

## 주요 클래스: `SHA1Hash`

### `__init__(self, data)`
- **목적**: 클래스를 초기화합니다.
- **매개변수**: `data` (해시할 입력 데이터, 바이트 문자열).
- **속성**:
  - `self.data`: 입력 데이터.
  - `self.h`: 5개의 32비트 정수로 구성된 초기 해시값 (상수).

### `rotate(n, b)` (Static Method)
- **목적**: 비트 회전 연산을 수행합니다.
- **동작**: 정수 `n`을 `b`비트만큼 왼쪽으로 순환 시프트(Left Rotate)시킵니다.

### `padding(self)`
- **목적**: 입력 메시지를 512비트(64바이트)의 배수가 되도록 패딩(Padding)합니다.
- **동작**:
  1. 메시지 끝에 `1` 비트(바이트로는 `0x80`)를 추가합니다.
  2. 메시지 길이가 512비트의 배수보다 64비트 모자랄 때까지 `0`으로 채웁니다.
  3. 마지막 64비트에 원본 메시지의 비트 길이를 빅 엔디안(Big-endian) 정수로 추가합니다.

### `split_blocks(self)`
- **목적**: 패딩된 데이터를 64바이트(512비트) 단위의 블록 리스트로 나눕니다.

### `expand_block(self, block)`
- **목적**: 64바이트 블록을 80개의 32비트 정수 배열(`w`)로 확장합니다.
- **동작**:
  - 처음 16개(`w[0]~w[15]`)는 입력 블록의 데이터를 그대로 사용합니다.
  - 나머지 64개(`w[16]~w[79]`)는 이전 값들을 XOR 연산하고 회전시켜 생성합니다.

### `final_hash(self)`
- **목적**: 전체 해시 계산 과정을 수행하고 최종 해시값을 반환합니다.
- **알고리즘 동작**:
  1. `padding()`과 `split_blocks()`를 호출하여 데이터를 준비합니다.
  2. 각 블록에 대해 다음을 반복합니다:
     - `expand_block()`으로 80개의 워드를 생성합니다.
     - 초기 해시값 `h`를 변수 `a, b, c, d, e`에 복사합니다.
     - 80회의 라운드를 수행하며 비트 연산 및 논리 연산(`f`, `k` 값 변경)을 통해 `a, b, c, d, e`를 갱신합니다.
     - 라운드 종료 후, 현재 블록의 결과를 누적 해시값 `h`에 더합니다.
  3. 최종 `h` 값들을 16진수 문자열로 변환하여 이어 붙인 뒤 반환합니다.

## 사용법

`if __name__ == "__main__":` 블록을 통해 커맨드 라인에서 직접 실행하거나 테스트를 수행할 수 있습니다.

```bash
# 문자열 해시 계산
python sha1.py --string "Hello World!!"

# 파일 해시 계산
python sha1.py --file "filename.txt"
```

인자 없이 실행하면 기본 문자열("Hello World!! Welcome to Cryptography")에 대한 해시를 출력합니다.

## 테스트
- `SHA1HashTest` 클래스는 Python의 내장 `hashlib` 라이브러리의 결과와 이 구현의 결과를 비교하여 정확성을 검증합니다.
