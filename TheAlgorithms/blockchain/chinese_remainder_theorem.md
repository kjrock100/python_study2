# Python 코드 분석: chinese_remainder_theorem.py

이 문서는 `chinese_remainder_theorem.py` 파일에 구현된 '중국인의 나머지 정리(Chinese Remainder Theorem)' 관련 파이썬 코드에 대해 상세히 설명합니다.

## 개요

이 코드는 여러 개의 합동 방정식의 해를 찾는 **중국인의 나머지 정리**를 구현합니다. 특히 두 개의 합동 방정식 시스템을 푸는 데 초점을 맞추고 있습니다.

n ≡ r1 (mod n1) n ≡ r2 (mod n2)


위 식은 "정수 n을 n1으로 나눈 나머지는 r1이고, n2로 나눈 나머지는 r2이다"를 의미합니다. 코드는 이러한 조건을 만족하는 정수 `n`을 찾는 여러 함수를 포함하고 있습니다.

## 주요 함수 분석

### 1. `extended_euclid(a, b)`

이 함수는 **확장 유클리드 호제법**을 재귀적으로 구현합니다.

-   **목적**: 두 정수 `a`와 `b`가 주어졌을 때, `a*x + b*y = gcd(a, b)`를 만족하는 정수 계수 `x`와 `y`를 찾습니다. (`gcd`는 최대공약수)
-   **반환값**: `(x, y)` 튜플을 반환합니다.
-   **중요성**: 이 함수는 중국인의 나머지 정리를 풀기 위해 필요한 모듈러 곱셈의 역원(modular multiplicative inverse)을 계산하는 데 핵심적인 역할을 합니다.

### 2. `invert_modulo(a, n)`

모듈러 `n`에 대한 `a`의 곱셈 역원을 계산합니다.

-   **목적**: `(a * b) ≡ 1 (mod n)`을 만족하는 정수 `b`를 찾습니다.
-   **동작 원리**:
    1.  `extended_euclid(a, n)`를 호출하여 `a*x + n*y = gcd(a, n)`을 만족하는 `x`와 `y`를 얻습니다.
    2.  만약 `gcd(a, n) = 1`이라면, `a*x ≡ 1 (mod n)`이 성립하므로 `x`가 바로 곱셈 역원이 됩니다.
    3.  함수는 `extended_euclid`가 반환한 첫 번째 값(`x`에 해당)을 역원으로 간주하고, 음수일 경우 양수로 변환하여 반환합니다.
-   **주의사항**: 현재 구현은 `gcd(a, n)`이 1이 아닌 경우(역원이 존재하지 않는 경우)를 명시적으로 처리하지 않아 부정확한 결과를 반환할 수 있습니다.

### 3. `chinese_remainder_theorem(n1, r1, n2, r2)`

확장 유클리드 호제법을 직접 사용하여 중국인의 나머지 정리를 풉니다.

-   **목적**: `n ≡ r1 (mod n1)`과 `n ≡ r2 (mod n2)`를 모두 만족하는 해 `n`을 찾습니다.
-   **동작 원리**:
    1.  `extended_euclid(n1, n2)`를 호출하여 `x`, `y`를 구합니다.
    2.  `n = r2*x*n1 + r1*y*n2` 공식을 사용하여 해를 구성합니다.
    3.  결과 `n`을 `(n % m + m) % m` (여기서 `m = n1 * n2`)을 통해 표준적인 양의 정수 해로 변환하여 반환합니다.

### 4. `chinese_remainder_theorem2(n1, r1, n2, r2)`

`invert_modulo` 함수를 사용하여 중국인의 나머지 정리를 푸는 두 번째 방법입니다.

-   **동작 원리**: `invert_modulo`를 사용하여 `n1`과 `n2`의 각 모듈러스에 대한 역원을 구한 뒤, 이를 `chinese_remainder_theorem`과 동일한 공식에 대입하여 해를 구합니다.
-   **차이점**: 내부적으로 `extended_euclid`를 직접 호출하는 대신, `invert_modulo`라는 추상화된 함수를 사용하여 가독성을 높였습니다.

## 코드의 문제점 및 개선 제안

1.  **부정확한 Doctest**: `chinese_remainder_theorem(6, 1, 4, 3)`의 예시 테스트는 `14`를 기대하지만, `14`는 올바른 해가 아닙니다. (`14 % 6 = 2 ≠ 1`, `14 % 4 = 2 ≠ 3`). 실제로 이 합동 방정식의 해는 존재하지 않습니다.
2.  **비-서로소(Non-coprime) 경우의 처리**: 중국인의 나머지 정리는 모듈러스(`n1`, `n2`)가 서로소(`gcd(n1, n2) = 1`)일 때 유일한 해가 보장됩니다. 현재 코드는 서로소가 아닌 경우에도 해를 계산하지만, 사용된 공식은 일반적인 경우가 아니므로 부정확한 결과를 낼 수 있습니다. 해가 존재할 조건(`r1 ≡ r2 (mod gcd(n1, n2))`)을 확인하는 로직이 필요합니다.
3.  **`extended_euclid`의 불완전한 반환**: 현재 `extended_euclid` 함수는 `gcd` 값을 반환하지 않아, 역원이 존재하는지 여부를 호출하는 쪽에서 판단하기 어렵습니다. `(gcd, x, y)`를 모두 반환하도록 수정하는 것이 좋습니다.

## 요약

제공된 코드는 중국인의 나머지 정리를 푸는 두 가지 접근 방식을 보여주는 좋은 예시입니다. 하지만 모듈러스가 서로소가 아닌 일반적인 경우와 오류 처리에 대한 고려가 부족하여 실제 적용 시에는 주의가 필요합니다. 코드를 더 견고하게 만들기 위해서는 해의 존재 조건을 확인하고, `extended_euclid` 함수의 반환값을 개선하는 것이 좋습니다.
