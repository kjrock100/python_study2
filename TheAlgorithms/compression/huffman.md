# `huffman.py` 코드 설명

이 문서는 `huffman.py` 파이썬 스크립트를 설명합니다. 이 스크립트는 파일 내 문자의 등장 빈도를 기반으로 가변 길이 코드를 생성하여 데이터를 효율적으로 인코딩하는 **허프만 코딩(Huffman Coding)** 알고리즘을 구현합니다.

## 목차
1.  허프만 코딩이란?
2.  클래스 설명
    -   `Letter`
    -   `TreeNode`
3.  함수 설명
    -   `parse_file(file_path)`
    -   `build_tree(letters)`
    -   `traverse_tree(root, bitstring)`
    -   `huffman(file_path)`
4.  실행 방법
5.  코드 개선 제안

## 허프만 코딩이란?

허프만 코딩은 무손실 데이터 압축에 사용되는 탐욕 알고리즘(greedy algorithm)입니다. 기본적인 아이디어는 다음과 같습니다.

1.  **빈도 분석**: 텍스트에서 각 문자가 얼마나 자주 등장하는지 분석합니다.
2.  **가변 길이 코드 할당**:
    -   자주 등장하는 문자에는 짧은 비트 코드(예: 'e' -> `01`)를 할당합니다.
    -   드물게 등장하는 문자에는 긴 비트 코드(예: 'z' -> `111010`)를 할당합니다.
3.  **트리 구조**: 이 과정을 위해 **허프만 트리**라는 이진 트리를 사용합니다. 각 문자는 리프 노드(leaf node)가 되고, 이 노드들을 빈도가 낮은 순서대로 결합하여 트리를 만들어 나갑니다.

결과적으로 전체 텍스트를 표현하는 데 필요한 총 비트 수가 줄어들어 데이터가 압축됩니다.

## 클래스 설명

### `Letter`

파일에 등장하는 각 문자와 그 빈도, 그리고 최종적으로 할당될 비트 코드를 저장하는 데이터 클래스입니다.

-   `letter`: 문자 자체 (예: 'a')
-   `freq`: 해당 문자의 등장 횟수
-   `bitstring`: 허프만 코드가 저장될 딕셔너리 (예: `{'a': '010'}`)

### `TreeNode`

허프만 트리를 구성하는 내부 노드를 나타내는 클래스입니다.

-   `freq`: 두 자식 노드의 빈도를 합산한 값.
-   `left`, `right`: 왼쪽 및 오른쪽 자식 노드. 이 자식 노드는 `Letter` 객체이거나 또 다른 `TreeNode` 객체일 수 있습니다.

## 함수 설명

### `parse_file(file_path: str) -> list[Letter]`

지정된 파일을 읽어 각 문자의 빈도를 계산하고, 이를 `Letter` 객체의 리스트로 만들어 빈도순으로 정렬하여 반환합니다.

-   **알고리즘**:
    1.  파일을 한 글자씩 읽으면서 각 문자의 등장 횟수를 딕셔너리에 기록합니다.
    2.  이 딕셔너리를 `Letter` 객체의 리스트로 변환합니다.
    3.  빈도가 낮은 순으로 리스트를 정렬하여 반환합니다.

### `build_tree(letters: list[Letter]) -> Letter | TreeNode`

정렬된 `Letter` 리스트를 사용하여 허프만 트리를 구축합니다.

-   **알고리즘 (탐욕 알고리즘)**:
    1.  리스트에 노드가 하나만 남을 때까지 다음을 반복합니다.
    2.  리스트에서 빈도가 가장 낮은 두 개의 노드(왼쪽, 오른쪽)를 꺼냅니다.
    3.  두 노드의 빈도를 합산하여 새로운 `TreeNode`(부모 노드)를 만듭니다.
    4.  이 부모 노드를 다시 리스트에 추가하고, 리스트를 빈도순으로 다시 정렬합니다.
    5.  최종적으로 남는 하나의 노드가 트리의 루트(root)가 됩니다.

### `traverse_tree(root: Letter | TreeNode, bitstring: str) -> list[Letter]`

완성된 허프만 트리를 재귀적으로 순회하여 각 `Letter`에 대한 비트 코드를 생성합니다.

-   **알고리즘**:
    -   루트 노드에서 시작하여 왼쪽 자식으로 이동할 때는 비트 코드에 '0'을, 오른쪽 자식으로 이동할 때는 '1'을 추가합니다.
    -   리프 노드(`Letter` 객체)에 도달하면, 그때까지 만들어진 비트 코드를 해당 문자의 코드로 할당합니다.

### `huffman(file_path: str) -> None`

전체 허프만 코딩 과정을 실행하고, 파일의 내용을 허프만 코드로 변환하여 출력합니다.

-   **동작**:
    1.  `parse_file`로 문자 빈도 리스트를 얻습니다.
    2.  `build_tree`로 허프만 트리를 생성합니다.
    3.  `traverse_tree`로 각 문자에 대한 코드 맵을 만듭니다.
    4.  다시 파일을 열어 한 글자씩 읽으면서, 해당 문자의 코드를 화면에 출력합니다.

## 실행 방법

이 스크립트는 커맨드 라인에서 파일 경로를 인자로 받아 실행합니다.

1.  **준비**: 인코딩할 텍스트 파일(예: `sample.txt`)을 준비합니다.
2.  **실행**:
    ```bash
    python huffman.py sample.txt
    ```

**실행 결과 예시:**
```
Huffman Coding  of sample.txt: 
101 1100 1101 1101 1111 ... 
```

## 코드 개선 제안

1.  **`build_tree` 함수의 효율성**: 현재 `build_tree` 함수는 루프마다 `response.sort()`를 호출합니다. 리스트의 길이가 N일 때, 정렬은 O(N log N)의 시간이 걸리므로 전체 시간 복잡도는 O(N² log N)이 됩니다. 이 부분은 **최소 힙(min-heap)** 자료구조(`heapq` 모듈)를 사용하면 훨씬 효율적으로 개선할 수 있습니다. 힙을 사용하면 가장 작은 두 원소를 꺼내는 데 O(log N), 새로운 원소를 추가하는 데 O(log N)이 걸려, 전체 시간 복잡도를 O(N log N)으로 줄일 수 있습니다.

2.  **클래스 구조**: `Letter`와 `TreeNode`는 유사한 속성(`freq`)을 공유하며, 트리를 구성하는 요소라는 공통점이 있습니다. 이들을 상속 관계(예: `Node`라는 부모 클래스)로 묶거나, `dataclasses` 모듈을 사용하여 더 간결하게 정의할 수 있습니다.

3.  **파일 이중 읽기**: 현재 `huffman` 함수는 파일의 내용을 두 번 읽습니다(한 번은 빈도 분석, 한 번은 인코딩). 파일이 매우 클 경우 비효율적일 수 있습니다. `parse_file`에서 파일 내용을 메모리에 저장해두고, 인코딩 시에는 이 저장된 내용을 사용하면 파일 I/O를 줄일 수 있습니다. (단, 메모리 사용량은 증가합니다.)

4.  **출력 방식**: 현재는 인코딩된 결과를 화면에 출력만 합니다. 이 결과를 압축된 파일로 저장하고, 이를 다시 원래 텍스트로 복원하는 **디코딩(decoding)** 기능을 추가하면 완전한 압축/해제 프로그램이 될 수 있습니다.